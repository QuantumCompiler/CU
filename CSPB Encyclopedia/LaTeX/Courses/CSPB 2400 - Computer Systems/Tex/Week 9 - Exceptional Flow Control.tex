\clearpage

\renewcommand{\ChapTitle}{Exceptional Flow Control}
\renewcommand{\SectionTitle}{Exceptional Flow Control}

\chapter{\ChapTitle}
\section{\SectionTitle}
\horizontalline{0}{0}

\subsection{Assigned Reading}

The reading assignment for this week is from, \Textbook:

\begin{itemize}
    \item \pdflink{\ReadingMatDir Chapter 8.1 - Exceptions.pdf}{Chapter 8.1 - Exceptions}
    \item \pdflink{\ReadingMatDir Chapter 8.2 - Processes.pdf}{Chapter 8.2 - Processes}
    \item \pdflink{\ReadingMatDir Chapter 8.3 - System Call Error Handling.pdf}{Chapter 8.3 - System Call Error Handling}
    \item \pdflink{\ReadingMatDir Chapter 8.4 - Process Control.pdf}{Chapter 8.4 - Process Control}
\end{itemize}

\subsection{Lectures}

The lecture videos for this week are:

\begin{itemize}
    \item \lecture{https://www.youtube.com/watch?v=tyAuMNOZp-o}{Exceptional Control Flow - Exceptions}{15}
    \item \lecture{https://www.youtube.com/watch?v=4fywWrIef80}{Exceptional Control Flow - Processes}{9}
    \item \lecture{https://www.youtube.com/watch?v=1MgWx1_PGXU}{Exceptional Control Flow - Process Control}{43}
    \item \lecture{https://www.youtube.com/watch?v=_IiuvMfNlIg}{Exceptional Control Flow - Shells}{16}
\end{itemize}

\noindent The lecture notes for this week are:

\begin{itemize}
    \item \pdflink{\LecNoteDir Exceptional Control Flow - Exceptions And Processes I Lecture Notes.pdf}{Exceptional Control Flow - Exceptions And Processes I Lecture Notes}
    \item \pdflink{\LecNoteDir Exceptional Control Flow - Exceptions And Processes II Lecture Notes.pdf}{Exceptional Control Flow - Exceptions And Processes II Lecture Notes}
    \item \pdflink{\LecNoteDir Exceptional Control Flow - Exceptions And Processes III Lecture Notes.pdf}{Exceptional Control Flow - Exceptions And Processes III Lecture Notes}
    \item \pdflink{\LecNoteDir Exceptional Control Flow - Signals And Nonlocal Jumps I Lecture Notes.pdf}{Exceptional Control Flow - Signals And Nonlocal Jumps I Lecture Notes}
    \item \pdflink{\LecNoteDir Exceptional Control Flow - Signals And Nonlocal Jumps II Lecture Notes.pdf}{Exceptional Control Flow - Signals And Nonlocal Jumps II Lecture Notes}
    \item \pdflink{\LecNoteDir Exceptional Control Flow - Signals And Nonlocal Jumps III Lecture Notes.pdf}{Exceptional Control Flow - Signals And Nonlocal Jumps III Lecture Notes}
    \item \pdflink{\LecNoteDir Exceptional Control Flow - Signals And Nonlocal Jumps IV Lecture Notes.pdf}{Exceptional Control Flow - Signals And Nonlocal Jumps IV Lecture Notes}
\end{itemize}

\subsection{Assignments}

The assignment for this week is:

\begin{itemize}
    \item \href{https://github.com/QuantumCompiler/CU/tree/main/CSPB%202400%20-%20Computer%20Systems/Assignments/Assignment%204%20-%20Performance%20Lab}{Performance Lab}
    \item \href{https://github.com/QuantumCompiler/CU/tree/main/CSPB%202400%20-%20Computer%20Systems/Assignments/Assignment%204%20-%20Performance%20Lab}{Performance Lab Extra Credit}
    \item \href{https://github.com/QuantumCompiler/CU/tree/main/CSPB%202400%20-%20Computer%20Systems/Assignments/Assignment%204%20-%20Performance%20Lab}{Performance Lab Interview}
\end{itemize}

\subsection{Chapter Summary}

The chapter that is being covered this week is \textbf{Chapter 8: Exceptional Flow Control}. The first section that is being covered from this chapter this week is \textbf{Section 8.1: Exceptions}.

\begin{notes}{Section 8.1: Exceptions}
    \subsubsection*{Understanding Exceptions in Exceptional Control Flow}

    Exceptions are events that disrupt the normal flow of control in a program. They can arise from hardware errors, such as division by zero and invalid memory access, or from software errors, like 
    segmentation faults. Exceptional Control Flow (ECF) provides a mechanism for handling such exceptions, allowing a program to recover from unexpected states or terminate gracefully. \vspace*{1em}
    
    \subsubsection*{Types of Exceptions}
    
    Exceptions can be broadly classified into four types based on their source:
    
    \begin{itemize}
        \item \textbf{Interrupts}: Asynchronous exceptions caused by external events (e.g., I/O operations completing).
        \item \textbf{Traps}: Synchronous exceptions that occur as a result of executing an instruction (e.g., system calls).
        \item \textbf{Faults}: Errors that can potentially be corrected, allowing the program to resume (e.g., page faults).
        \item \textbf{Aborts}: Serious errors indicating a problem from which the program cannot recover (e.g., hardware failures).
    \end{itemize}
    
    \vspace*{1em}
    
    \subsubsection*{Handling Exceptions}
    
    The operating system (OS) plays a crucial role in managing exceptions. When an exception occurs, the OS must:
    
    \begin{enumerate}
        \item Determine the type of exception and the context in which it occurred.
        \item Save the current state of the CPU (e.g., program counter, registers).
        \item Transfer control to an appropriate exception handler.
        \item Depending on the handler's action, either return control to the point where the exception occurred, or terminate the process.
    \end{enumerate}
    
    Exception handlers are specialized pieces of code designed to address specific types of exceptions. They can be part of the OS kernel, part of libraries, or embedded within applications.
    
    \vspace*{1em}
    
    \begin{highlight}[Example of Software Exception Handling]
        \subsubsection*{Division by Zero Error Handling}
    
        In many programming environments, attempting to divide by zero will raise an exception. A typical handler might:
    
    \begin{code}[C]
    if (denominator == 0) {
        throw DivisionByZeroException;
    } else {
        result = numerator / denominator;
    }
    \end{code}
    
        This pseudo-code demonstrates how an application can explicitly check for division by zero and throw an exception, which can then be caught and handled appropriately, either by terminating the 
        process or by performing an alternative action.
    \end{highlight}
    
    \subsubsection*{Considerations in Exception Handling}
    
    \begin{itemize}
        \item Exception handling requires careful design to ensure that all potential exceptions are accounted for, and that the system can recover gracefully from them.
        \item The performance of a system can be affected by the overhead of checking for and handling exceptions. This needs to be balanced with the need for robustness and reliability.
        \item Portability concerns arise as different hardware platforms and operating systems might implement exception handling differently. It's important for software developers to be aware of 
        these differences.
    \end{itemize}    
\end{notes}

The next section that is being covered this week is \textbf{Section 8.2: Processes}.

\begin{notes}{Section 8.2: Processes}
    \subsubsection*{Processes}

    A process is a fundamental concept in operating systems, representing an instance of a running program. It encompasses the program's code (also known as text), its current activity represented by 
    the program counter, contents of the processor's registers, and the process's address space, which includes the memory allocated to it. Processes provide the abstraction needed for the efficient 
    and protected execution of multiple programs on a single computing system. \vspace*{1em}
    
    \subsubsection*{Key Components of a Process}
    
    \begin{itemize}
        \item \textbf{Process Identifier (PID)}: A unique number that identifies a process. It is used by the system to manage process resources and scheduling.
        \item \textbf{Text Section}: Contains the executable code of the program.
        \item \textbf{Data Section}: Includes global and static variables, allocated and managed by the compiler.
        \item \textbf{Heap}: Dynamically allocated memory during process run time, used for data that varies in size.
        \item \textbf{Stack}: Stores temporary data such as function parameters, return addresses, and local variables.
        \item \textbf{Program Counter (PC)}: Indicates the next instruction to execute.
        \item \textbf{Registers}: Small, fast storage locations within the CPU that hold instructions, addresses, and data.
    \end{itemize}
    
    \subsubsection*{Process Life Cycle}
    
    The life cycle of a process includes several states:
    \begin{itemize}
        \item \textbf{New}: The process is being created.
        \item \textbf{Ready}: The process is waiting to be assigned to a processor.
        \item \textbf{Running}: Instructions are being executed.
        \item \textbf{Waiting}: The process is waiting for some event to occur (such as an I/O completion or a signal).
        \item \textbf{Terminated}: The process has finished execution.
    \end{itemize}
    
    \subsubsection*{Process Control Block (PCB)}
    
    Each process is represented in the operating system by a process control block (PCB), also known as a task control block. It contains important information about the process, including:
    \begin{itemize}
        \item Process state
        \item Process privileges
        \item Process ID
        \item Program counter
        \item CPU registers
        \item CPU scheduling information
        \item Memory-management information
        \item Accounting information
        \item I/O status information
    \end{itemize}
    
    \subsubsection*{Process Scheduling}
    
    The operating system uses process scheduling to manage the execution of multiple processes, allocating CPU time in a way that maximizes the efficiency of its use. Common scheduling algorithms include 
    Round-Robin, First-Come, First-Served, and Priority Scheduling.
    
    \subsubsection*{Considerations}
    
    \begin{itemize}
        \item Efficient process management is crucial for the overall performance and responsiveness of a system.
        \item Security and isolation between processes prevent them from interfering with each other or accessing unauthorized resources.
        \item The creation, scheduling, and management of processes require careful consideration to avoid issues such as deadlocks and resource starvation.
    \end{itemize}    
\end{notes}

The next section that is being covered from this chapter this week is \textbf{Section 8.3: System Call Error Handling}.

\begin{notes}{Section 8.3: System Call Error Handling}
    \subsubsection*{System Call Error Handling}

    System call error handling is a crucial aspect of robust software development, ensuring that programs can deal with failures in system calls gracefully. System calls, which provide the interface 
    between a running program and the operating system, can fail for various reasons, such as invalid arguments, resource exhaustion, or permissions issues. Proper error handling allows a program to 
    check for potential failures, take corrective action, or fail gracefully, improving the program's reliability and user experience. \vspace*{1em}
    
    \subsubsection*{Mechanisms for Error Reporting}
    
    In Unix-like operating systems, system calls report errors through a global variable \texttt{errno}. Upon a successful system call, \texttt{errno} is not modified by the system, and if an error 
    occurs, the system call returns an error indicator (usually -1) and sets \texttt{errno} to a value that indicates the specific error.
    
    \begin{itemize}
        \item \textbf{Checking Return Values}: Programs must check the return value of system calls to determine if an error occurred. If the return value indicates an error (e.g., -1 for many system calls), 
        the program should then check \texttt{errno} to determine the cause of the failure.
        \item \textbf{Interpreting \texttt{errno}}: The \texttt{errno} variable is set to specific error codes, defined in \texttt{<errno.h>}, such as \texttt{EACCES}, \texttt{ENOSPC}, \texttt{EINVAL}, 
        etc., indicating the reason for the error.
        \item \textbf{Using \texttt{perror} and \texttt{strerror}}: The \texttt{perror()} function prints a human-readable error message to standard error, based on the current value of \texttt{errno}. 
        Alternatively, \texttt{strerror()} returns a pointer to the textual representation of the current \texttt{errno} value, allowing for error messages to be formatted or logged by the program.
    \end{itemize}
    
    \subsubsection*{Best Practices for Error Handling}
    
    \begin{itemize}
        \item \textbf{Consistent Error Checking}: Systematically check for errors after every system call that can fail. Neglecting these checks can lead to unpredictable program behavior.
        \item \textbf{Meaningful Error Reporting}: Use \texttt{perror()} or \texttt{strerror()} to provide clear, meaningful error messages to the user or log files, aiding in debugging and user support.
        \item \textbf{Resource Management}: Ensure that resources (e.g., file descriptors, memory) are properly released or cleaned up in error conditions to avoid resource leaks.
        \item \textbf{Error Recovery}: Where possible, implement strategies to recover from errors, such as retrying the system call, using alternative methods, or failing gracefully with a clear error message.
    \end{itemize}
    
    \subsubsection*{Considerations}
    
    \begin{itemize}
        \item System call error handling is platform-specific; the mechanisms described apply to Unix-like systems, and similar but different approaches are used on other operating systems.
        \item The granularity and specificity of error codes can vary, affecting how precisely a program can respond to different error conditions.
        \item Proper error handling can significantly increase the complexity of code. It's important to balance the thoroughness of error checks with code readability and maintainability.
    \end{itemize}    
\end{notes}

The last section that is being covered from this chapter this week is \textbf{Section 8.4: Process Control}.

\begin{notes}{Section 8.4: Process Control}
    \subsubsection*{Process Control}

    Process control in operating systems encompasses the mechanisms and strategies used to manage the lifecycle of processes. This includes process creation, execution, suspension, resumption, and 
    termination. Effective process control is vital for the efficient allocation of system resources, ensuring system responsiveness and stability. \vspace*{1em}
    
    \subsubsection*{Key Aspects of Process Control}
    
    \begin{itemize}
        \item \textbf{Process Creation}: Processes can be created during system boot, by executing a system call, or by a running process (parent) that creates another process (child). The creation 
        involves allocating a unique process identifier (PID), allocating memory, and initializing the process control block (PCB).
        \item \textbf{Process Execution}: The state of a process transitions from ready to running when the scheduler selects it. Execution involves the process performing its designated operations, 
        such as computations and I/O.
        \item \textbf{Process Suspension and Resumption}: Processes may be suspended (moved from running to waiting state) due to I/O requests, interrupts, or higher priority processes becoming runnable. 
        Suspended processes can be resumed (moved from waiting to ready state) once the reason for suspension is resolved.
        \item \textbf{Process Termination}: A process terminates when it finishes its execution or when it is explicitly killed due to an error or a kill command. Termination involves reclaiming any 
        resources allocated to the process.
    \end{itemize}
    
    \subsubsection*{Process Control Block (PCB)}
    
    The PCB is a data structure maintained by the operating system for every process. It contains important information necessary for process control:
    
    \begin{itemize}
        \item Process State: The current state of the process (e.g., running, waiting, ready).
        \item Process Privileges: Information regarding the process's allowed operations.
        \item Process ID: A unique identifier for the process.
        \item CPU Registers: The contents of the processor's registers for the process.
        \item CPU Scheduling Information: Priority, scheduling queue pointers, and other scheduling parameters.
        \item Memory-Management Information: Page tables, segment tables, and limits.
        \item Accounting Information: Amount of processor time used, time limits, job or process numbers.
        \item I/O Status Information: List of I/O devices allocated to the process, a list of open files, etc.
    \end{itemize}
    
    \subsubsection*{Context Switching}
    
    Context switching is the process of saving the state of a currently running process so that it can be resumed at a later time and loading the state of another process to begin its execution. This 
    is crucial for multitasking, allowing the CPU to switch between processes efficiently.
    
    \subsubsection*{Considerations}
    
    \begin{itemize}
        \item \textbf{Efficiency}: Process control mechanisms must be designed to minimize overhead, especially for context switching, to maintain system performance.
        \item \textbf{Security and Isolation}: Proper management of process privileges and resources is necessary to prevent unauthorized access and ensure system stability.
        \item \textbf{Scalability}: The process control system must be capable of managing a large number of processes efficiently.
    \end{itemize}    
\end{notes}