\clearpage

\renewcommand{\ChapTitle}{Exceptional Flow Control}
\renewcommand{\SectionTitle}{Exceptional Flow Control}

\chapter{\ChapTitle}
\section{\SectionTitle}
\horizontalline{0}{0}

\subsection{Assigned Reading}

The reading assignment for this week is from, \Textbook:

\begin{itemize}
    \item \textbf{Chapter 8.5 - Signals}
    \item \textbf{Chapter 8.6 - Nonlocal Jumps}
    \item \textbf{Chapter 8.7 - Tools For Manipulating Processes}
\end{itemize}

\subsection{Lectures}

The lecture videos for this week are:

\begin{itemize}
    \item \lecture{https://www.youtube.com/watch?v=xx7j-fRX0Tc}{Exceptional Control Flow - Sending Signals}{13}
    \item \lecture{https://www.youtube.com/watch?v=U-_Sxx7Pmp8}{Exceptional Control Flow - Receiving Signals}{29}
    \item \lecture{https://www.youtube.com/watch?v=xOKps4qz8uM}{Exceptional Control Flow - Non-Local Jumps}{10}
    \item \lecture{https://www.youtube.com/watch?v=VG1eAvIsduQ}{A Tale of Two Signals (Shell Lab)}{8}
\end{itemize}

\noindent The lecture notes for this week are:

\begin{itemize}
    \item \pdflink{\LecNoteDir Exceptional Control Flow - Signals And Nonlocal Jumps IV Lecture Notes.pdf}{Exceptional Control Flow - Signals And Nonlocal Jumps IV Lecture Notes}
    \item \pdflink{\LecNoteDir Virtual Memory - Concepts I Lecture Notes.pdf}{Virtual Memory - Concepts I Lecture Notes}
    \item \pdflink{\LecNoteDir Virtual Memory - Concepts II Lecture Notes.pdf}{Virtual Memory - Concepts II Lecture Notes}
    \item \pdflink{\LecNoteDir Virtual Memory - Systems I Lecture Notes.pdf}{Virtual Memory - Systems Lecture Notes}
\end{itemize}

\subsection{Assignments}

The assignment for this week is:

\begin{itemize}
    \item \href{https://github.com/QuantumCompiler/CU/tree/main/CSPB%202400%20-%20Computer%20Systems/Assignments/Assignment%204%20-%20Performance%20Lab}{Performance Lab}
    \item \href{https://github.com/QuantumCompiler/CU/tree/main/CSPB%202400%20-%20Computer%20Systems/Assignments/Assignment%204%20-%20Performance%20Lab}{Performance Lab Extra Credit}
    \item \href{https://github.com/QuantumCompiler/CU/tree/main/CSPB%202400%20-%20Computer%20Systems/Assignments/Assignment%204%20-%20Performance%20Lab}{Performance Lab Interview}
\end{itemize}

\newpage

\subsection{Chapter Summary}

The chapter that is being covered for this week is \textbf{Chapter 8: Exceptional Control Flow}. The first section that is being covered from this chapter this week is \textbf{Section 8.5: Signals}.

\begin{notes}{Section 8.5: Signals}
    \subsubsection*{Signals}

    Signals are a form of software interrupt used to notify a process that an event has occurred. In UNIX and UNIX-like operating systems, signals are a primary method for exceptional control flow, 
    allowing processes to be interrupted and to handle predefined or user-defined events asynchronously. \vspace*{1em}
    
    \subsubsection*{Key Aspects of Signals}
    
    \begin{itemize}
        \item \textbf{Signal Generation}: Signals can be generated by the operating system in response to hardware exceptions (e.g., division by zero, segmentation fault), by explicit user request 
        via command-line utilities (e.g., `kill` command), or by a process calling the `kill` function to send a signal to another process.
        \item \textbf{Signal Delivery}: When a signal is generated, the operating system delivers it to the target process. If the process has registered a signal handler, that handler is executed; 
        otherwise, the default action associated with the signal is performed.
        \item \textbf{Signal Handling}: Processes can choose to ignore signals, handle them using a custom signal handler, or accept the default behavior defined by the operating system. The default 
        actions can include terminating the process, ignoring the signal, or suspending/resuming the process.
        \item \textbf{Types of Signals}: There are various signals defined in UNIX-like systems, such as SIGINT (interrupt from keyboard), SIGTERM (termination signal), SIGSEGV (segmentation violation), 
        and SIGALRM (timer signal), each with its specific intended use.
    \end{itemize}
    
    \subsubsection*{Signal Handling Mechanisms}
    
    To handle signals, a process must specify how each signal is processed, using system calls to change the disposition of a signal. The `signal` and `sigaction` system calls are commonly used for this purpose:
    
    \begin{itemize}
        \item \textbf{signal}: Allows a process to specify the signal handling function for a particular signal.
        \item \textbf{sigaction}: Provides a more comprehensive and reliable mechanism than `signal`, allowing detailed control over signal handling, including blocking additional signals during the 
        handling of a current signal.
    \end{itemize}
    
    \subsubsection*{Considerations in Signal Handling}
    
    \begin{itemize}
        \item \textbf{Atomicity}: Signal handlers should execute quickly and avoid non-reentrant functions to prevent data races and inconsistencies.
        \item \textbf{Synchronization}: Careful synchronization is necessary when signals are used in concurrent programs, to avoid deadlocks and race conditions.
        \item \textbf{Portability}: Signal behavior can vary across different UNIX-like systems, so portable programs should rely on well-defined, consistent signal handling features.
    \end{itemize}    
\end{notes}

The next section that is being covered from this chapter this week is \textbf{Section 8.6: Nonlocal Jumps}.

\begin{notes}{Section 8.6: Nonlocal Jumps}
    \subsubsection*{Nonlocal Jumps}

    Nonlocal jumps are a mechanism in C that allows the control flow of a program to transfer directly from a point in the program to another without returning to the caller. This feature is implemented 
    through the setjmp and longjmp functions in the C standard library. Nonlocal jumps are particularly useful in handling error conditions and implementing control structures that cannot be easily 
    expressed with standard C constructs. \vspace*{1em}
    
    \subsubsection*{Key Aspects of Nonlocal Jumps}
    
    \begin{itemize}
        \item \textbf{setjmp}: This function initializes a jump buffer with the current execution context, including the program counter, stack pointer, and set of CPU registers, for later use by 
        longjmp. It returns 0 when called directly and a nonzero value when returning from a call to longjmp.
        \item \textbf{longjmp}: This function transfers control back to the point where the corresponding setjmp was called, using the jump buffer to restore the execution context. The longjmp 
        function does not return to its caller but causes setjmp to return again, this time with a nonzero value specified as the second argument to longjmp.
        \item \textbf{Usage}: Nonlocal jumps are often used in error handling where an error in a deeply nested function call needs to unwind the call stack quickly to a recovery point. They can also 
        be used to implement coroutines or escape from complex control structures.
        \item \textbf{Caution}: While powerful, nonlocal jumps should be used sparingly due to their potential to disrupt normal control flow and resource management. They can complicate program 
        understanding and maintenance, and they may skip the execution of critical cleanup code (e.g., resource deallocation).
    \end{itemize}
    
    \subsubsection*{Considerations in Using Nonlocal Jumps}
    
    \begin{itemize}
        \item \textbf{Resource Leakage}: Jumping out of a scope without executing the corresponding destructors or free operations can lead to resource leaks. Programmers need to ensure manual cleanup 
        before performing a nonlocal jump.
        \item \textbf{Variable Volatility}: Variables that should retain their values across a longjmp should be declared as volatile to prevent undesired optimizations by the compiler.
        \item \textbf{Signal Safety}: Nonlocal jumps can be used in signal handlers to exit from a blocking system call or an infinite loop. However, their use should be carefully evaluated for signal 
        safety and reentrancy.
        \item \textbf{Compatibility and Portability}: The behavior of setjmp and longjmp is well-defined in the C standard, but their interaction with complex program structures, third-party libraries, 
        and system resources may vary across different environments and should be thoroughly tested.
    \end{itemize}    
\end{notes}

The last section that is being covered from this chapter this week is \textbf{Section 8.7: Tools For Manipulating Processes}.

\begin{notes}{Section 8.7: Tools For Manipulating Processes}
    \subsubsection*{Tools For Manipulating Processes}

    Tools for manipulating processes are essential for process management in operating systems. These tools allow users and system administrators to create, monitor, control, and terminate processes. 
    Understanding and effectively using these tools is crucial for system maintenance and optimization. \vspace*{1em}
    
    \subsubsection*{Key Tools and Their Functions}
    
    \begin{itemize}
        \item \textbf{ps (Process Status)}: Displays information about active processes. It can show the process ID, current state, memory usage, and command line that initiated the process, among 
        other details. Users can tailor the output using various options.
        \item \textbf{top}: Provides a dynamic, real-time view of the system's running processes. It displays a list of processes that consume the most system resources at any given time, making it 
        invaluable for monitoring system performance and identifying processes that may be affecting system efficiency.
        \item \textbf{kill}: Sends a signal to a process, typically to terminate the process. While commonly used for termination, the `kill` command can send any signal to processes, allowing for 
        versatile process control.
        \item \textbf{nice}: Changes the scheduling priority of a process, which can be used to influence the process's execution order. Processes with higher priority are allocated more CPU time 
        than those with lower priority, affecting their performance.
        \item \textbf{nohup}: Allows a process to continue running in the background even after the user has logged out from the system. This is particularly useful for long-running processes in remote sessions.
        \item \textbf{jobs}: Lists all jobs that were started in the current shell session, showing their job number, state (running, stopped, etc.), and the command line that started them.
        \item \textbf{bg (Background)}: Continues a stopped process by running it in the background. This is useful for multitasking and freeing up the terminal while a process runs.
        \item \textbf{fg (Foreground)}: Moves a background process into the foreground, making it the current job and allowing the user to interact with it directly through the terminal.
    \end{itemize}
    
    \subsubsection*{Considerations for Process Manipulation}
    
    \begin{itemize}
        \item \textbf{System Performance}: Careful management of process priorities and resources is essential to maintain system performance. Overloading the system with high-priority processes can 
        lead to resource contention and decreased system responsiveness.
        \item \textbf{Security}: Privileged processes and the ability to send signals to processes require appropriate permissions. Misuse can lead to security vulnerabilities, such as unauthorized 
        access or denial of service.
        \item \textbf{Stability}: Terminating processes, especially system or critical processes, should be done with caution to avoid system instability or data loss.
        \item \textbf{Compatibility}: Some tools or their options might behave differently across Unix/Linux distributions. It's important to refer to the specific documentation for your operating system.
    \end{itemize}    
\end{notes}