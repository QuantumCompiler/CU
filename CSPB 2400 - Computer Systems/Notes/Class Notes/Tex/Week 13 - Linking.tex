\clearpage

\renewcommand{\ChapTitle}{Linking}
\renewcommand{\SectionTitle}{Linking}

\chapter{\ChapTitle}
\section{\SectionTitle}
\horizontalline{0}{0}

\subsection{Assigned Reading}

The reading assignment for this week is from, \Textbook:

\begin{itemize}
    \item \textbf{Chapter 7.1 - Compiler Drivers}
    \item \textbf{Chapter 7.2 - Static Linking}
    \item \textbf{Chapter 7.3 - Object Files}
    \item \textbf{Chapter 7.4 - Relocatable Object Files}
\end{itemize}

\subsection{Lectures}

The lecture videos for this week are:

\begin{itemize}
    \item \lecture{https://www.youtube.com/watch?v=jAdJ2yG8hks}{Virtual Memory - Safer Allocation In C++}{18}
    \item \lecture{https://www.youtube.com/watch?v=ZNxS8ZBcBEg}{Memory Exploits - Meltdown And Spectre}{31}
    \item \lecture{https://www.youtube.com/watch?v=CiA9LUW3Le0}{Linking And Loading}{26}
\end{itemize}

\noindent The lecture notes for this week are:

\begin{itemize}
    \item \pdflink{\LecNoteDir Linking And Loading - Linking Lecture Notes.pdf}{Linking And Loading - Linking Lecture Notes}
    \item \pdflink{\LecNoteDir Linking And Loading - Loading And Libraries Lecture Notes.pdf}{Linking And Loading - Loading And Libraries Lecture Notes}
    \item \pdflink{\LecNoteDir Linking And Loading - Interposition Lecture Notes.pdf}{Linking And Loading - Interposition Lecture Notes}
    \item \pdflink{\LecNoteDir Security Compromise Via Speculation, Ccaches And Page Tables Lecture Notes.pdf}{Security Compromise Via Speculation, Ccaches And Page Tables Lecture Notes}
\end{itemize}

\subsection{Assignments}

The assignment for this week is:

\begin{itemize}
    \item \href{https://github.com/QuantumCompiler/CU/tree/main/CSPB%202400%20-%20Computer%20Systems/Assignments/Assignment%205%20-%20Shell%20Lab}{Shell Lab}
    \item \href{https://github.com/QuantumCompiler/CU/tree/main/CSPB%202400%20-%20Computer%20Systems/Assignments/Assignment%205%20-%20Shell%20Lab}{Shell Lab Interview}
\end{itemize}

\newpage

\subsection{Chapter Summary}

The chapter that is being covered this week is \textbf{Chapter 7: Linking}. The first section that is being covered from this chapter this week is \textbf{Section 7.1: Compile Drivers}.

\begin{notes}{Section 7.1: Compile Drivers}
    \subsection*{Compile Drivers}

    Compile drivers, often referred to as "compilers" in a broader sense, are sophisticated tools that automate the sequence of compilation, assembly, and linking to transform source code into executable 
    programs. They simplify the complex procedures involved in software development by providing a unified interface to manage these tasks. \vspace*{1em}
    
    \subsubsection*{Overview of Functionality:}
    
    \begin{itemize}
        \item Compile drivers serve as the interface between the programmer and the lower-level software stack required to process and translate high-level source code into machine executable form.
        \item They streamline the development process by integrating the functionalities of preprocessors, compilers, assemblers, and linkers.
        \item Common examples include \texttt{gcc}, \texttt{clang} for C/C++ programming, and \texttt{javac} for Java, which are widely used in Unix/Linux and other development environments.
    \end{itemize}
    
    \subsubsection*{Detailed Workflow:}
    
    Compile drivers execute several critical steps to build executables:
    \begin{enumerate}
        \item \textbf{Preprocessing:} The preprocessor takes the initial source code files and processes directives such as \texttt{\#include} (for including other source or header files) and \texttt{\#define} 
        (for defining macros). This step also involves removing comments and expanding macros.
        \item \textbf{Compilation:} In this crucial phase, the preprocessed source code is compiled into assembly instructions tailored to the target processor's architecture. This involves syntax and semantic 
        checks to ensure the code adheres to the language standards.
        \item \textbf{Assembly:} Assembly language code generated by the compiler is then converted into machine code by an assembler. The output is typically in the form of object files, which contain 
        machine code and metadata about the code like symbol tables and relocation information.
        \item \textbf{Linking:} The linker takes multiple object files produced during assembly and combines them into a single executable program. It resolves symbols and addresses, managing external 
        and internal dependencies efficiently.
    \end{enumerate}
    
    \subsubsection*{Advanced Features and Usage:}
    
    \begin{itemize}
        \item Beyond basic compilation and linking, compile drivers often offer extensive support for debugging, optimization flags, and the configuration of libraries or modules.
        \item They facilitate the maintenance of large codebases by automating the build sequences, ensuring consistent application builds across different development setups.
        \item Compile drivers also help in cross-platform software development by abstracting away the details of the target environment and handling platform-specific compilation tasks internally.
    \end{itemize}
    
    \subsubsection*{Importance in Modern Development:}
    
    \begin{itemize}
        \item In modern software engineering, compile drivers are indispensable for their role in automating and optimizing the development pipeline.
        \item They enhance developer productivity by reducing manual tasks and simplifying the integration of various code components and libraries.
        \item By handling various optimizations internally, compile drivers ensure that applications run efficiently on target hardware, which is crucial for performance-critical applications.
    \end{itemize}
\end{notes}

The next section that is being covered from this chapter this week is \textbf{Section 7.2: Static Linking}.

\begin{notes}{Section 7.2: Static Linking}
    \subsection*{Static Linking}

    Static linking refers to the process of combining various pieces of program code and data into a single executable file at compile time. This linking method integrates all the required libraries 
    and modules directly into the application's executable, which can be executed without further dependency resolution at runtime. \vspace*{1em}
    
    \subsubsection*{Fundamental Principles:}
    
    \begin{itemize}
        \item Static linking involves the inclusion of library routines and modules directly in the applicationâ€™s executable file, rather than relying on separate shared library files at runtime.
        \item It is performed by a linker program that searches and processes object files and libraries to create a single executable.
        \item One of the main advantages of static linking is that it creates self-contained executables that are portable and do not require external library dependencies on the target system.
    \end{itemize}
    
    \subsubsection*{Key Processes in Static Linking:}
    
    Static linking executes several systematic steps to produce a self-sufficient executable:
    \begin{enumerate}
        \item \textbf{Symbol Resolution:} The linker identifies and matches external symbols in the object files to their corresponding definitions in the library or other object files. It ensures 
        that all referenced code and data are accounted for in the final executable.
        \item \textbf{Relocation:} Adjusts code and data references in the object files so they point to the appropriate locations in the final executable. This step is necessary because the actual 
        memory locations where the executable will be loaded cannot be known in advance.
        \item \textbf{Space Allocation:} Allocates space for both code and data in the final executable, organizing these components as defined by the executable format (such as ELF in Unix/Linux).
        \item \textbf{Output Generation:} Produces the final executable file, writing the linked code and data into a single file according to the executable format specifications.
    \end{enumerate}
    
    \subsubsection*{Advantages and Disadvantages:}
    
    \begin{itemize}
        \item \textbf{Advantages:}
            \begin{itemize}
                \item \emph{Reliability:} Since all necessary components are contained within the executable, the application is not susceptible to library version conflicts.
                \item \emph{Portability:} The executable does not depend on external libraries being present on the system where it runs, enhancing its portability.
                \item \emph{Performance:} Loading a statically linked executable can be faster than loading a dynamically linked one because there are no dynamic resolution delays.
            \end{itemize}
        \item \textbf{Disadvantages:}
            \begin{itemize}
                \item \emph{File Size:} Statically linked executables are typically larger than dynamically linked ones, as they include all the code and data they need.
                \item \emph{Resource Use:} Each statically linked executable duplicates code that could be shared between executables if dynamically linked, consuming more disk space and potentially more memory.
                \item \emph{Updates and Maintenance:} Updating a statically linked library requires re-linking and redistributing the entire executable, which can complicate maintenance.
            \end{itemize}
    \end{itemize}
    
    \subsubsection*{Common Use Cases:}
    
    \begin{itemize}
        \item Static linking is often used in scenarios where high reliability and portability are critical, such as in embedded systems or when distributing software to environments where library 
        availability cannot be guaranteed.
        \item It is also favored in situations where execution speed is a priority and the overhead of dynamic linking might be detrimental to performance.
    \end{itemize}
\end{notes}

The next section that is being covered from this chapter this week is \textbf{Section 7.3: Object Files}.

\begin{notes}{Section 7.3: Object Files}
    \subsection*{Object Files}

    Object files are a crucial component in the software build process, acting as intermediaries between source code and the executable program. They contain machine code, data, and metadata created by the compiler during the compilation of source code. Object files are later used by linkers to create executable or shared library files. \vspace*{1em}
    
    \subsubsection*{Characteristics and Structure:}
    
    \begin{itemize}
        \item Object files are produced by the compilation of source code files and contain a variety of information including compiled code (text segment), initialized data (data segment), uninitialized data (bss segment), symbols, and debugging information.
        \item They typically adhere to a standardized binary format, which varies by operating system and processor architecture, such as ELF (Executable and Linkable Format) on Unix-based systems, COFF (Common Object File Format) on Windows, and Mach-O on macOS.
        \item The structure of an object file includes headers that describe its size and layout, sections containing actual code and data, and a section header table that points to the different sections within the file.
    \end{itemize}
    
    \subsubsection*{Key Components:}
    
    Object files mainly consist of several distinct sections, each serving specific purposes:
    \begin{enumerate}
        \item \textbf{Header:} Contains metadata about the object file, including the format version, architecture, and size of sections.
        \item \textbf{Text Section:} Includes executable instructions of the program. This is the code that is executed when the program runs.
        \item \textbf{Data Section:} Contains initialized global and static variables.
        \item \textbf{BSS Section:} Used for declaring variables that are not initialized by the programmer. At runtime, the operating system initializes them to zero.
        \item \textbf{Relocation Information:} Necessary for linking, this part helps in modifying symbol references once their actual memory addresses are known.
        \item \textbf{Symbol Table:} Lists functions and variables names used or defined in the object file, along with information about size, type, and location.
        \item \textbf{Debugging Information:} Stores data that helps debuggers in mapping the executable code back to the source code locations.
    \end{enumerate}

    \begin{highlight}[Practical Example]
        To illustrate, consider a simple C program:
    \begin{code}[C]
    #include <stdio.h>
    
    int global_var = 5;
    
    int main() {
        printf("Hello, world!\n");
        return 0;
    }
    \end{code}
        Compiling this program (e.g., using `gcc -c program.c`) would produce an object file (`program.o`). This object file contains:
        \begin{itemize}
            \item A text section with the machine code for `main` and `printf`.
            \item A data section that includes the value of `global\_var`.
            \item Relocation information that includes references to `printf` which may be resolved during linking.
            \item Symbol table entries for `main`, `global\_var`, and `printf`.
        \end{itemize}
    \end{highlight}
    
    
    \subsubsection*{Usage and Importance:}
    
    \begin{itemize}
        \item Object files allow multiple source code files to be compiled separately and linked together later, supporting modular programming and improving compilation time.
        \item They enable the reuse of compiled code. A library's object files can be linked into different programs without needing to recompile the library.
        \item Object files are fundamental for static and dynamic linking processes, facilitating flexible software development and distribution models.
    \end{itemize}    
\end{notes}

The last section that is being covered from this chapter this week is \textbf{Section 7.4: Relocatable Object Files}.

\begin{notes}{Section 7.4: Relocatable Object Files}
    \subsection*{Relocatable Object Files}

    Relocatable object files are a type of object file specifically designed to be used in multiple program environments by allowing the relocation of its code and data. They play a critical role in 
    the linking phase of program compilation where different pieces of code are combined to form a single executable. \vspace*{1em}
    
    \subsubsection*{Core Concepts:}
    
    \begin{itemize}
        \item Relocatable object files are generated by compilers with the expectation that a linker will later adjust or "relocate" the addresses within them. This process enables the object files to 
        function correctly wherever they are loaded into memory.
        \item They are essential for creating large programs where code and data are spread across multiple source files or when using external libraries that reside in separate files.
        \item The primary feature that distinguishes relocatable object files from other types is their use of relative addressing for data and function references, which requires relocation entries 
        to be resolved by the linker.
    \end{itemize}
    
    \subsubsection*{Structure and Elements:}
    
    A relocatable object file typically includes several key elements that facilitate its integration and relocation:
    \begin{enumerate}
        \item \textbf{Header:} Specifies the file's architecture and provides meta-information about section sizes and the number of relocation entries.
        \item \textbf{Text Section:} Contains the executable code with placeholders for addresses that need to be fixed at link time.
        \item \textbf{Data Section:} Includes initialized global and static variables, again with placeholders for actual memory addresses.
        \item \textbf{BSS Section:} Reserved for uninitialized data that does not occupy file space but requires space allocation during execution.
        \item \textbf{Relocation Section:} Lists all the places in the text and data sections where addresses must be corrected; this includes both absolute and relative addresses.
        \item \textbf{Symbol Table:} Contains names and other attributes of various identifiers found in the code, like variable and function names.
    \end{enumerate}

    \begin{highlight}[Example]
        Consider a C function that calculates the sum of two integers:
    \begin{code}[C]
    int add(int a, int b) {
        return a + b;
    }
    \end{code}
        When compiled into a relocatable object file (e.g., `gcc -c add.c`), it would include:
        \begin{itemize}
            \item A text section with the machine code for the `add` function.
            \item Relocation information that indicates where and how to adjust the machine code if the function's location in memory changes.
            \item A symbol table entry for `add`, marking it as an external symbol that may be referenced from other files.
        \end{itemize}
    \end{highlight}

    \subsubsection*{Importance and Usage:}
    
    \begin{itemize}
        \item Relocatable object files allow developers to compile source files independently of each other, thus facilitating incremental builds and the use of shared libraries.
        \item They enable the linker to optimize program layout in memory by arranging code and data segments efficiently, which can improve runtime performance and reduce resource usage.
        \item This type of object file is fundamental for supporting dynamic linking where executables and libraries are not fixed until program load time.
    \end{itemize}
    
    \subsubsection*{Challenges:}
    
    \begin{itemize}
        \item Managing and resolving relocation entries can be complex and time-consuming, especially for large applications with numerous external dependencies.
        \item Errors in relocation can lead to runtime errors that are difficult to debug, such as incorrect function calls or data access violations.
    \end{itemize}    
\end{notes}