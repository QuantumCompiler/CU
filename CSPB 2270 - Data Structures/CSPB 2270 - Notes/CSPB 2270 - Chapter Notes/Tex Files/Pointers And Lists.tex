\clearpage

\chapter{Week 3}

\section{Pointers \& Lists}

\horizontalline

\subsection{Activites}
The following are the activities that are planned for Week 3 of this course.
\begin{itemize}
    \item Reading Quiz(s) from last week are due on Monday.
    \item Assignment-1 (Vector10) is due Tuesday.
    \item Read the zyBook chapter(s) assigned and complete the reading quiz(s) by next Monday.
    \item Read the C++ refresher or access other resources to improve your skills.
    \item Watch videos on Pointers and Linked Lists.
    \item Implement the examples In this week videos on your Jupytherhub machine.
    \item Watch the video about Assignment-2 (Linked List).
    \item Access the GitHub Classroom to get your Assignment-2 repository  (assignment due next Tuesday).
\end{itemize}

\subsection{Lectures}
Here are the lectures that can be found for this week:
\begin{itemize}
    \item \href{https://applied.cs.colorado.edu/mod/hvp/view.php?id=45893}{Pointers in C/C++}
    \item \href{https://applied.cs.colorado.edu/mod/hvp/view.php?id=45894}{Pass Objects by Value / Reference}
    \item \href{https://applied.cs.colorado.edu/mod/hvp/view.php?id=45895}{Stack vs. Heap}
    \item \href{https://applied.cs.colorado.edu/mod/hvp/view.php?id=45896}{Smart Pointers in C++}
    \item \href{https://applied.cs.colorado.edu/mod/hvp/view.php?id=45897}{shared\_ptr Examples}
    \item \href{https://applied.cs.colorado.edu/mod/hvp/view.php?id=45898}{Linked List}
\end{itemize}

\subsection{Programming Assignment}
The programming assignment for Week 3 - \href{https://github.com/cu-cspb-2270-Summer-2023/pa2-RelativiBit}{Linked List}.

\subsection{Chapter 4 - Pointers}

The first chapter of this week is Chapter 4 - Pointers.

\subsection*{Sec. 4.1 - Why Pointers?}

Pointers are variables that store memory addresses as their values. They play a crucial role in programming languages, allowing direct manipulation and access to memory locations. Pointers enable efficient data manipulation 
by providing a way to refer to and modify data indirectly, rather than making unnecessary copies. They are especially useful in data structures and algorithms, as they facilitate dynamic memory allocation, efficient traversal 
of linked data structures, and enable the passing of values by reference. However, working with pointers requires careful management to avoid memory leaks and undefined behavior, making them a fundamental concept to understand 
in programming

\begin{solution}[Pointers Example]
    Below is an example of pointers in C++:

    \horizontalline

    \begin{verbatim}    
    #include <iostream>

    int main() {
        int value = 42;
        int* pointer = &value;
    
        std::cout << "Value: " << value << std::endl;
        std::cout << "Memory address of value: " << &value << std::endl;
        std::cout << "Pointer value: " << pointer << std::endl;
        std::cout << "Dereferenced pointer value: " << *pointer << std::endl;
    
        *pointer = 99;
    
        std::cout << "Updated value: " << value << std::endl;
    
        return 0;
    }
        \end{verbatim}
    
        \horizontalline
        
    In this code snippet, we declare a variable value and initialize it with the value 42. We then declare a pointer variable pointer of type int* (pointer to an integer) and assign it the memory address of the value variable using 
    the \& (address-of) operator. By dereferencing the pointer with *pointer, we can access the value stored at that memory address, which is the value of value. We can modify the value of value indirectly by assigning a new value 
    to *pointer. In this case, we update it to 99. Finally, we print the original and updated values to demonstrate how modifying the value through the pointer affects the original variable.
\end{solution}

\subsection*{Sec. 4.2 - Pointer Basics}

\subsubsection{Pointer Variables}

In object-oriented programming (OOP), pointer variables serve as essential tools for managing objects and dynamic memory allocation. Pointers allow for the creation and manipulation of objects indirectly by holding the memory address 
of the object instead of its actual value. This enables efficient memory usage and facilitates complex data structures and polymorphism. By using pointer variables, objects can be accessed and modified across different scopes and functions, 
providing flexibility and modularity in OOP. Additionally, pointers play a crucial role in managing resources and memory deallocation through techniques such as garbage collection or smart pointers. Understanding pointer variables in OOP 
is vital for effective memory management and advanced object manipulation.

\subsubsection{Dereferencing a Pointer}

Dereferencing pointers is the process of accessing the value stored at the memory address pointed to by a pointer variable. By using the dereference operator (*) in programming languages like C++ or C, we can retrieve and manipulate the actual 
value associated with the pointer. Dereferencing allows us to read or modify the data pointed to by the pointer, enabling direct access and manipulation of objects, arrays, or structures in memory. Care must be taken when dereferencing pointers 
to ensure that they are pointing to valid memory locations, as accessing invalid or uninitialized memory can lead to unpredictable behavior or runtime errors. Understanding how to properly dereference pointers is crucial for efficient and correct 
utilization of pointer variables in programming.

\subsubsection{Null Pointers}

Null pointers are special pointers that do not point to a valid memory location. They are used to indicate that a pointer variable does not currently refer to any object or memory address. In programming languages like C++ or C, a null pointer is 
typically represented by the value 0 or nullptr. Null pointers are useful in several scenarios, such as initializing pointers before they are assigned valid addresses, checking for the absence of a valid object reference, or signaling the end of 
data structures like linked lists. However, accessing or dereferencing a null pointer can lead to runtime errors like segmentation faults, so it is important to check for nullness before using a pointer to avoid such issues. Understanding null 
pointers is crucial for handling pointer variables and ensuring proper memory safety in programming.

\begin{solution}[Pointer Basics Example]
    Below is an example of pointer basics in C++:
    

    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>

    int main() {
        int* ptr = nullptr;  // Initializing pointer to null
    
        if (ptr == nullptr) {
            std::cout << "Pointer is null!" << std::endl;
        } else {
            std::cout << "Pointer is not null!" << std::endl;
        }
    
        int value = 42;
        ptr = &value;  // Assigning valid memory address to the pointer
    
        if (ptr != nullptr) {
            std::cout << "Pointer is not null!" << std::endl;
            std::cout << "Dereferenced value: " << *ptr << std::endl;
        }
    
        return 0;
    }
        \end{verbatim}
    
        \horizontalline

    In this code, we start by initializing a pointer variable `ptr' to `nullptr', indicating that it does not currently point to a valid memory address. We then check if the pointer is null using the `==' comparison operator and print a 
    corresponding message. Next, we declare an integer variable `value' and assign it the value 42. We assign the memory address of `value' to the pointer `ptr' using the address-of operator `\&'. After verifying that the pointer is not 
    null, we dereference it using the `*' operator to access the value stored at the memory address pointed to by `ptr'. Finally, we print the dereferenced value

    In this example, we demonstrate the use of null pointers to indicate the absence of a valid memory address. We initialize the pointer to null, check its nullness, and then assign it a valid address. By dereferencing the pointer, we 
    retrieve the value stored in the memory location pointed to by the pointer. The example highlights the importance of checking for nullness before accessing or dereferencing pointers to avoid runtime errors. Understanding and properly 
    handling null pointers is crucial for ensuring memory safety and preventing unexpected behavior in C++ programs.
\end{solution}

\subsection*{Sec. 4.3 - Operators, new, delete, and The Member Access}

\subsubsection{The `new' Operator}

In C++, the `new' operator is used to dynamically allocate memory for objects or data structures at runtime. It returns a pointer to the allocated memory, allowing us to initialize and work with objects that reside in the heap rather than 
the stack. The `new' operator is followed by the type of the object being allocated, and it automatically handles memory allocation and initialization. This allows for dynamic memory management and flexibility in creating objects whose size 
or lifetime may not be known at compile-time. It is important to pair the `new' operator with the corresponding `delete' or `delete[]' operator to deallocate the memory and avoid memory leaks. Proper understanding and usage of the `new' 
operator are essential for managing dynamic memory allocation and object creation in C++ programs.

\subsubsection{Member Access Operator}

In programming languages like C++ and C\#, the member access operator (->) is used to access members (variables or functions) of an object through a pointer to that object. It provides a convenient way to interact with objects when working 
with pointers, allowing access to the members of the object without dereferencing the pointer explicitly. By using the member access operator, we can access and modify the object's members, invoke member functions, or retrieve values stored 
in member variables. This operator simplifies the syntax and readability when working with objects through pointers, enabling seamless interaction with the underlying object's members and behavior. Understanding and correctly utilizing the 
member access operator is crucial when working with objects through pointers in object-oriented programming languages.

\subsubsection{The `delete' Operator}

In C++ and similar languages, the `delete' operator is used to deallocate memory that was previously allocated dynamically using the `new' operator. It is used to free the memory occupied by objects or arrays created with `new', ensuring 
efficient memory management. When `delete' is applied to a single object, the memory occupied by that object is released. When `delete[]' is used, it is used to deallocate memory allocated for arrays. By properly deallocating memory with 
the `delete' operator, we prevent memory leaks and improve the overall performance of our programs. It is important to note that the `delete' operator should only be used for memory that was dynamically allocated with `new'. Using `delete' 
on a non-dynamically allocated or previously freed memory can lead to undefined behavior and program crashes. Understanding how to correctly apply the `delete' operator is crucial for effective memory management in C++ programs.

\begin{solution}[Pointer Operators Example]
    Below is an example of pointer operators in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>
    
    int main() {
        int* ptr = new int;  // Dynamically allocate memory for an integer
    
        *ptr = 42;  // Assign a value to the dynamically allocated memory
    
        std::cout << "Dynamically allocated value: " << *ptr << std::endl;
    
        delete ptr;  // Deallocate the dynamically allocated memory
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline

    In this code, we use the `new' operator to dynamically allocate memory for an integer. The `new' operator allocates memory from the heap and returns a pointer to the allocated memory. We assign the address of this memory to the 
    pointer variable `ptr'. We then assign the value 42 to the memory location pointed to by `ptr' using the dereference operator `*ptr'. Finally, we print the value stored in the dynamically allocated memory using `std::cout'
    
    To properly manage memory and prevent memory leaks, we use the `delete' operator to deallocate the dynamically allocated memory when we no longer need it. In this example, we deallocate the memory pointed to by `ptr' using `delete ptr'. 
    This frees up the memory for reuse by the system. It is essential to pair every `new' operation with a corresponding `delete' operation to avoid memory leaks and ensure efficient memory management
\end{solution}

\subsection*{Sec. 4.4 - String Functions With Pointers}

\subsubsection{C String Library Functions}

The C string library functions provide a set of built-in functions for working with null-terminated strings in the C programming language. These functions allow for efficient manipulation, searching, comparison, and copying of strings. 
Some commonly used C string library functions include `strlen()' to calculate the length of a string, `strcpy()' and `strncpy()' to copy strings, `strcmp()' and `strncmp()' to compare strings, `strcat()' and `strncat()' to concatenate 
strings, and `strstr()' to search for a substring within a string. These functions provide powerful tools for handling strings in C, making string manipulation and processing tasks more convenient and efficient. Understanding and utilizing 
the C string library functions are essential for effective string handling in C programs.

\subsubsection{C String Search Functions}

C string search functions are part of the C string library and provide efficient mechanisms for searching substrings within null-terminated strings. These functions offer ways to locate occurrences of specific characters or entire substring 
patterns within a larger string. Commonly used C string search functions include `strchr()' to find the first occurrence of a character, `strrchr()' to find the last occurrence of a character, `strstr()' to locate the first occurrence of a 
substring, and `strpbrk()' to search for any character from a set within a string. These functions simplify the process of searching and locating specific patterns within strings, enabling efficient text processing and manipulation in C 
programming. Understanding and utilizing C string search functions are essential for tasks such as parsing, pattern matching, and text analysis in C programs.

\begin{solution}[C String Functions Example]
    Below is an example of C string functions that involve pointers:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <stdio.h>
    #include <string.h>
    
    int main() {
        char str[] = "Hello, World!";
        char *ptr;
    
        ptr = strchr(str, 'W');
        if (ptr != NULL) {
            printf("Found: %s\n", ptr);
        } else {
            printf("Not found!\n");
        }
    
        ptr = strstr(str, "World");
        if (ptr != NULL) {
            printf("Found: %s\n", ptr);
        } else {
            printf("Not found!\n");
        }
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline

    In this code, we declare a null-terminated string `str' containing the text "Hello, World!". We then use the `strchr()' function to search for the first occurrence of the character 'W' within the string `str'. If the character is found, `strchr()' 
    returns a pointer to the first occurrence of 'W', which we assign to the pointer variable `ptr'. We then check if `ptr' is not `NULL' and print the result accordingly. Next, we use the `strstr()' function to search for the first occurrence of the 
    substring "World" within `str'. If the substring is found, `strstr()' returns a pointer to the start of the substring, which we assign to `ptr'. Again, we check if `ptr' is not `NULL' and print the result
    
    This example demonstrates how C string search functions can be used to locate specific characters or substrings within a larger string. By utilizing functions like `strchr()' and `strstr()', we can easily search for patterns and retrieve pointers 
    to the locations of the found substrings within the original string. These C string search functions provide powerful tools for text processing, pattern matching, and string manipulation in C programming, making it easier to perform various tasks 
    such as searching, parsing, and extracting information from strings
\end{solution}

\subsection*{Sec. 4.5 - A First Linked List}

Linked lists are a fundamental data structure used in computer science and programming to store and manage collections of data. A linked list is composed of nodes, where each node contains a value and a reference to the next node in the list. Unlike 
arrays, linked lists do not require contiguous memory allocation, enabling dynamic memory allocation and efficient insertion and deletion operations. Linked lists offer flexibility in size and structure, allowing for efficient insertion and removal of 
elements at any position. However, accessing elements in a linked list requires traversing through the list sequentially, making it less efficient for random access compared to arrays. Overall, linked lists are valuable for scenarios that involve frequent 
insertions or removals, dynamic size requirements, or situations where efficient memory utilization is essential.

\begin{solution}[Linked List Example]
    Below is an example of linked lists in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>
    
    struct Node {
        int data;
        Node* next;
    };
    
    class LinkedList {
    private:
        Node* head;
    
    public:
        LinkedList() : head(nullptr) {}
    
        void insert(int value) {
            Node* newNode = new Node;
            newNode->data = value;
            newNode->next = head;
            head = newNode;
        }
    
        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };
    
    int main() {
        LinkedList list;
    
        list.insert(5);
        list.insert(10);
        list.insert(15);
        list.insert(20);
    
        list.display();
    
        return 0;
    }
    \end{verbatim}
    \horizontalline
    
    In this code, we define a `Node' struct that represents a single node in the linked list. Each node contains a data field to hold the value and a `next' pointer to refer to the next node in the list. We then define a `LinkedList' class that has a `head' 
    pointer as a private member, which points to the first node in the list
    
    The `LinkedList' class provides two member functions. The `insert()' function inserts a new node at the beginning of the list. It creates a new node, assigns the given value to its `data' field, and updates the `next' pointer to point to the current 
    head. The `head' pointer is then updated to point to the newly inserted node. The `display()' function traverses the linked list and prints the values of each node. It starts from the head and continues moving to the next node until reaching the end 
    (i.e., when the `next' pointer is `nullptr'). In the `main()' function, we create an instance of the `LinkedList' class, insert several values into the list, and then call the `display()' function to print the values
    
    This example showcases a basic implementation of a linked list in C++. Linked lists are dynamic data structures that provide efficient insertion and deletion operations, making them suitable for scenarios where frequent modifications to the list are 
    required. By utilizing pointers to link nodes, linked lists offer flexibility and efficient memory utilization compared to other data structures like arrays. Understanding and utilizing linked lists are essential for managing and manipulating collections 
    of data in various programming scenarios
\end{solution}

\subsection*{Sec. 4.6 - Memory Regions, Heap / Stack}

In computer programming, memory regions are areas of memory that serve different purposes in managing data. The static memory region, also known as the global memory, stores static and global variables that are allocated at compile-time and have a fixed 
lifetime throughout the program execution. The stack memory region is used for storing local variables, function call frames, and other runtime data. It operates in a Last-In-First-Out (LIFO) manner, where memory is allocated and deallocated as functions 
are called and return. The heap memory region is a dynamically allocated memory area that is used for managing dynamic memory at runtime. It allows for dynamic allocation and deallocation of memory using mechanisms such as `new' and `delete' or `malloc()' 
and `free()'. The heap is more flexible than the stack and can be used to allocate memory for objects whose size or lifetime is not known at compile-time. Understanding the distinctions between static memory, stack memory, and heap memory is crucial for 
efficient memory management and proper allocation of resources in programming.

\begin{solution}[Memory Regions Example]
    Below is an example of memory regions in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>

    // Static memory region - global variable
    int globalVariable = 10;
    
    void stackFunction() {
        // Stack memory region - local variable
        int stackVariable = 20;
        std::cout << "Stack variable: " << stackVariable << std::endl;
    }
    
    int main() {
        // Static memory region - global variable
        std::cout << "Global variable: " << globalVariable << std::endl;
    
        stackFunction();
    
        // Heap memory region - dynamically allocated memory
        int* heapVariable = new int(30);
        std::cout << "Heap variable: " << *heapVariable << std::endl;
        delete heapVariable;
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline
    
    In this code, we demonstrate the different memory regions: static memory, stack memory, and heap memory. The `globalVariable' is allocated in the static memory region and has a global scope, accessible throughout the program. We print its value in 
    the `main()' function
    
    The `stackFunction()' represents a function, and any local variables declared inside it, such as `stackVariable', are allocated in the stack memory region. These variables have a limited lifetime within the scope of the function. We print the value 
    of `stackVariable' inside the function. Next, we allocate memory dynamically on the heap memory region using the `new' operator. We assign a value of 30 to `heapVariable' and print its value. It is important to note that memory allocated on the heap 
    must be deallocated using the `delete' operator to prevent memory leaks. We deallocate the memory at the end of `main()' using `delete'
    
    In summary, this example illustrates the distinctions between static memory, stack memory, and heap memory in C++. Static memory is used for global variables with a fixed lifetime, while stack memory is used for local variables within functions. Stack 
    memory allocation and deallocation are handled automatically as functions are called and return. Heap memory allows for dynamic memory allocation and deallocation using `new' and `delete', providing flexibility for objects with unknown size or lifetime. 
    Understanding these memory regions is crucial for efficient memory management and proper utilization of resources in C++ programs
\end{solution}

\subsection*{Sec. 4.7 - Memory Leaks}

Memory leaks occur when dynamically allocated memory is not properly deallocated or released after it is no longer needed. In programming, memory leaks can happen when the programmer forgets to free memory using the appropriate deallocation mechanisms, such 
as `delete' in C++ or `free()' in C. As a result, the allocated memory remains inaccessible, leading to a gradual accumulation of unused memory over time. Memory leaks can cause programs to consume excessive memory, leading to degraded performance, increased 
resource usage, and potentially causing the program to crash or terminate unexpectedly. Detecting and fixing memory leaks is crucial for efficient memory management, and it involves identifying and releasing dynamically allocated memory when it is no longer 
required, thus preventing unnecessary memory consumption and maintaining the stability and performance of the program.

\begin{solution}[Memory Leak Example]
    Below is an example of a memory leak in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>

    void memoryLeak() {
        int* ptr = new int(42);  // Dynamically allocate memory
    
        // The following line is missing the deallocation step
        // delete ptr;  // Uncommenting this line will fix the memory leak
    }
    
    int main() {
        memoryLeak();
    
        // More code...
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline

    In this code, we have a function `memoryLeak()' that demonstrates a memory leak scenario. Inside this function, we dynamically allocate memory using the `new' operator to create an integer with a value of 42 and assign it to the pointer variable `ptr'. 
    However, the crucial step of deallocating the dynamically allocated memory is missing. The `delete' operator, which would free the memory, is commented out in the code
    
    When `memoryLeak()' is called, memory is allocated for the integer but never released, resulting in a memory leak. The memory leak occurs because the program loses track of the allocated memory, making it inaccessible for future use. In this example, 
    the memory leak is intentional to demonstrate the concept, but in real-world scenarios, memory leaks are typically unintentional
    
    Memory leaks can cause the program to consume more and more memory over time, potentially leading to performance issues, resource exhaustion, or program crashes. Detecting and fixing memory leaks involves being diligent in deallocating dynamically 
    allocated memory using the appropriate deallocation mechanisms (`delete' in C++). By ensuring proper memory management, programs can avoid unnecessary memory consumption and maintain stability and efficiency
\end{solution}

\subsection*{Sec. 4.8 - Destructor}

Destructors are special member functions in object-oriented programming languages like C++ that are automatically called when an object is destroyed or goes out of scope. They have the same name as the class, preceded by a tilde (\~). Destructors are 
primarily used to clean up resources allocated by the object, such as releasing dynamically allocated memory or closing files or connections. They are particularly useful for ensuring proper resource management and preventing memory leaks or resource 
leaks. When an object is no longer needed, either because it goes out of scope or is explicitly deleted, the destructor is automatically invoked. The destructor allows the object to perform any necessary cleanup operations, freeing up resources and 
maintaining the integrity of the program. Understanding and implementing destructors appropriately is crucial for effective resource management and maintaining the overall robustness and efficiency of object-oriented programs.

\begin{solution}[Destructors Example]
    Below is an example of destructors in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>

    class Resource {
    private:
        int* data;
    
    public:
        Resource() {
            data = new int[10];
            std::cout << "Resource acquired." << std::endl;
        }
    
        ~Resource() {
            delete[] data;
            std::cout << "Resource released." << std::endl;
        }
    
        // Other member functions...
    };
    
    int main() {
        Resource myResource;
        // ...do some operations with myResource
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline

    In this code, we have a class `Resource' that manages a dynamically allocated array `data'. The constructor of the class, `Resource()', is responsible for acquiring the resource by allocating memory using the `new' operator. In this case, we allocate an 
    array of integers with a size of 10. Within the constructor, we display a message to indicate that the resource has been acquired
    
    The crucial aspect is the destructor, `~Resource()'. It is automatically invoked when the object of the `Resource' class goes out of scope, which happens when the `main()' function ends. The destructor takes care of releasing the allocated memory using 
    the `delete[]' operator to free the array. We also display a message in the destructor to indicate that the resource has been released. In the `main()' function, we create an object `myResource' of the `Resource' class. When `main()' finishes executing, 
    the `myResource' object goes out of scope, causing the destructor to be automatically called. As a result, the allocated memory is properly deallocated, ensuring efficient resource management
    
    The example illustrates the usage of a destructor in C++. Destructors are essential for cleaning up resources and performing necessary cleanup operations when an object is no longer needed. By implementing a destructor, developers can ensure proper resource 
    management, prevent memory leaks, and maintain the overall robustness and efficiency of their programs
\end{solution}

\subsection*{Sec. 4.9 - Copy Constructors}

Copy constructors are special member functions in object-oriented programming languages like C++ that are used to create a new object as a copy of an existing object of the same class. The copy constructor is invoked when a new object is initialized from an 
existing object, either by direct initialization or by passing an object as a function argument by value. It performs a member-wise copy of the data from the source object to the newly created object. Copy constructors are particularly useful when working with 
dynamically allocated memory or complex objects that require deep copying. By defining a custom copy constructor, developers can ensure that the new object has its own copy of the data, preventing unintended side effects due to shallow copying. Understanding 
and implementing copy constructors properly is crucial for correct object initialization and avoiding unexpected object state modifications when working with objects in C++.

\begin{solution}[Copy Constructor Example]
    Below is an example of copy constructors in C++:
    
    \horizontalline
    
    \begin{verbatim}   
        #include <iostream>
    
    class Car {
    private:
        std::string brand;
    
    public:
        Car(const std::string& carBrand) : brand(carBrand) {}
    
        // Copy constructor
        Car(const Car& other) : brand(other.brand) {
            std::cout << "Copy constructor called." << std::endl;
        }
    
        void displayBrand() {
            std::cout << "Brand: " << brand << std::endl;
        }
    };
    
    int main() {
        Car car1("Toyota");
        Car car2 = car1;  // Copy constructor is invoked here
    
        car1.displayBrand();
        car2.displayBrand();
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline
    
    In this code, we have a `Car' class that represents a car object with a `brand' attribute. The constructor `Car(const std::string\& carBrand)' initializes the `brand' attribute with the provided `carBrand' value
    
    The important aspect is the copy constructor `Car(const Car\& other)', which is invoked when a new `Car' object is created as a copy of an existing `Car' object. In the `Car' class, the copy constructor performs a member-wise copy of the `brand' attribute 
    from the source object to the newly created object. In this example, we also include a message to indicate when the copy constructor is called. In the `main()' function, we create an object `car1' with the brand "Toyota". Then, we initialize `car2' using 
    the copy constructor by assigning `car1' to `car2'. This invokes the copy constructor, creating a new `Car' object `car2' as a copy of `car1'. Afterward, we call the `displayBrand()' function on both `car1' and `car2' to verify that they hold the same brand value.
    
    The example demonstrates the usage of copy constructors in C++. Copy constructors are useful for creating new objects that are copies of existing objects, ensuring the proper initialization of member variables. By defining a copy constructor, developers 
    can perform a deep copy of data, preventing unintended side effects and maintaining the integrity of the copied object. Understanding and implementing copy constructors correctly are crucial for handling object copies and ensuring the expected behavior of 
    objects in C++ programs.
\end{solution}

\subsection*{Sec. 4.10 - Copy Assignment Operator}

\subsubsection{Default Assignment Operator Behavior}

In C++, the default assignment operator (`operator=') is a member function automatically generated by the compiler if no custom assignment operator is provided in the class. It performs a member-wise assignment, copying each member variable from the source object to 
the target object. The default assignment operator assigns the values of the member variables of the source object to the corresponding member variables of the target object. However, it does a shallow copy, which means that if the class contains dynamically allocated 
memory or resources, a shallow copy would simply copy the memory addresses rather than creating independent copies. This can lead to issues when multiple objects share the same resources. Therefore, if a class contains dynamically allocated memory or resources, it is 
recommended to define a custom assignment operator to perform a deep copy, ensuring that each object has its own separate copy of the resources.

\subsubsection{Overloading the Assignment Operator}

In C++, the assignment operator (`operator=') can be overloaded to provide a custom implementation for assigning one object to another of the same class. Overloading the assignment operator allows for more control over how the assignment operation is performed, 
especially when dealing with complex objects or dynamically allocated memory. By providing a custom assignment operator, developers can define their own rules for copying or transferring data between objects. This can involve deep copying of dynamically allocated memory, 
handling of resources, or any other necessary operations to ensure proper assignment semantics. Overloading the assignment operator enables greater flexibility and customization when it comes to assigning objects, allowing for more precise control over the behavior of 
the assignment operation in C++ programs.

\begin{solution}[Overloading Assignment Operator Example]
    Below is an example of overloading the assignment operator in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>

    class Car {
    private:
        std::string brand;
    
    public:
        Car(const std::string& carBrand) : brand(carBrand) {}
    
        // Overloaded assignment operator
        Car& operator=(const Car& other) {
            if (this != &other) {
                brand = other.brand;
                std::cout << "Assignment operator called." << std::endl;
            }
            return *this;
        }
    
        void displayBrand() {
            std::cout << "Brand: " << brand << std::endl;
        }
    };
    
    int main() {
        Car car1("Toyota");
        Car car2("Honda");
    
        car1.displayBrand();  // Output: Brand: Toyota
        car2.displayBrand();  // Output: Brand: Honda
    
        car2 = car1;  // Overloaded assignment operator is invoked here
    
        car1.displayBrand();  // Output: Brand: Toyota
        car2.displayBrand();  // Output: Brand: Toyota
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline
    
    In this code, we have a `Car' class with a `brand' attribute and a constructor `Car(const std::string\& carBrand)' to initialize the `brand' attribute
    
    The key aspect is the overloaded assignment operator `Car\& operator=(const Car\& other)'. This assignment operator is defined within the `Car' class and provides a custom implementation for assigning one `Car' object to another. It first checks if the source object 
    (`other') is not the same as the target object (`this') to avoid self-assignment. Then, it assigns the `brand' value of the source object to the target object and outputs a message indicating that the assignment operator is called. The assignment operator returns a 
    reference to the modified object. In the `main()' function, we create two `Car' objects, `car1' and `car2', with different brand names. We call the `displayBrand()' function to verify their respective brand names. Next, we assign `car1' to `car2' using the overloaded 
    assignment operator. This invokes the assignment operator, which copies the `brand' value of `car1' to `car2'. After the assignment, we call the `displayBrand()' function again to confirm that `car2' now has the same brand as `car1'.
    
    The example demonstrates the overloading of the assignment operator in C++. By providing a custom implementation for the assignment operator, developers can define their own rules for copying or transferring data between objects of the same class. This allows for greater 
    control over the behavior of the assignment operation, ensuring that objects are assigned correctly and any necessary operations, such as deep copying, are performed. Overloading the assignment operator provides flexibility and customization in handling object assignments in C++ programs.
\end{solution}

\subsection*{Sec. 4.11 - Rule of Three}

The Rule of Three in object-oriented programming (OOP) states that if a class requires the explicit definition of a destructor, copy constructor, or copy assignment operator, then it most likely requires all three. This rule arises from the need to properly manage resources, 
particularly when a class contains dynamically allocated memory or other non-copyable resources. By implementing all three functions, developers ensure that objects are correctly initialized, copied, and deallocated. Failure to adhere to the Rule of Three can lead to issues such as memory leaks, 
resource leaks, or unexpected object state modifications. By following this rule, developers can ensure proper resource management and maintain the integrity and behavior of objects in OOP programs.

\begin{solution}[Rule of Three Example]
    Below is an example of the rule of three in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>
    #include <cstring>
    
    class String {
    private:
        char* data;
    
    public:
        String(const char* str) {
            size_t length = strlen(str);
            data = new char[length + 1];
            strcpy(data, str);
        }
    
        ~String() {
            delete[] data;
        }
    
        String(const String& other) {
            size_t length = strlen(other.data);
            data = new char[length + 1];
            strcpy(data, other.data);
        }
    
        String& operator=(const String& other) {
            if (this != &other) {
                delete[] data;
                size_t length = strlen(other.data);
                data = new char[length + 1];
                strcpy(data, other.data);
            }
            return *this;
        }
    
        void print() {
            std::cout << data << std::endl;
        }
    };
    
    int main() {
        String s1("Hello");
        String s2 = s1;  // Copy constructor is invoked
    
        s1.print();  // Output: Hello
        s2.print();  // Output: Hello
    
        String s3("World");
        s2 = s3;  // Copy assignment operator is invoked
    
        s2.print();  // Output: World
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline

    In this code, we have a `String' class that represents a string object. The class manages a dynamically allocated character array `data' to hold the string
    
    The example adheres to the Rule of Three by defining the destructor, copy constructor, and copy assignment operator. The destructor `\~String()' deallocates the dynamically allocated memory held by `data'. The copy constructor `String(const String\& other)' creates a new `String' object 
    by making a deep copy of the `data' from the source object. The copy assignment operator `String\& operator=(const String\& other)' assigns the `data' from the source object to the target object, handling the deallocation and reallocation of memory.
    
    In the `main()' function, we create `String' objects `s1', `s2', and `s3'. We initialize `s1' with the string "Hello" and then create `s2' as a copy of `s1' using the copy constructor. We print the contents of both `s1' and `s2' to verify that they have the same string value. Next, we 
    create `s3' with the string "World" and assign it to `s2' using the copy assignment operator. This invokes the copy assignment operator, which deallocates the `data' of `s2' and copies the `data' from `s3'. We print the contents of `s2' to confirm that it now holds the string "World".
    
    The example demonstrates the Rule of Three in action, where the destructor, copy constructor, and copy assignment operator are implemented to ensure proper resource management and object behavior. By following this rule, developers can prevent memory leaks, resource leaks, or unexpected 
    object state modifications caused by incorrect copying or destruction of objects. Adhering to the Rule of Three is crucial when dealing with classes that manage resources or have non-copyable members, ensuring the correct behavior and integrity of objects in C++ programs.
\end{solution}

\subsection{Chapter 5 - Lists}

The second chapter of this week is Chapter 5 - Lists.

\subsection*{Sec. 5.1 - List Abstract Data Type (ADT)}

The list abstract data type (ADT) represents a collection of elements where each element is linked to the next element in the sequence. It allows for efficient insertion, deletion, and retrieval operations. The list ADT supports dynamic resizing, allowing for the storage of an arbitrary number 
of elements. Lists can be implemented using various data structures, such as linked lists or arrays. They provide flexibility in terms of element manipulation and are commonly used in scenarios where the order and accessibility of elements are important. The list ADT provides a versatile and efficient 
way to manage collections of data in computer programs, facilitating operations that involve sequential access and modification of elements.

\begin{solution}[List (ADT) Example]
    Below is an example of a list (ADT) in C++: 

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* next;

        Node(int value) : data(value), next(nullptr) {}
    };

    class LinkedList {
    private:
        Node* head;
        Node* tail;

    public:
        LinkedList() : head(nullptr), tail(nullptr) {}

        void insert(int value) {
            Node* newNode = new Node(value);
            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else {
                tail->next = newNode;
                tail = newNode;
            }
        }

        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };

    int main() {
        LinkedList myList;

        myList.insert(5);
        myList.insert(10);
        myList.insert(15);

        myList.display();  // Output: 5 10 15

        return 0;
    }
    \end{verbatim}

    \horizontalline

    In this code, we have a Node class that represents a node in a linked list. Each node holds an integer value (data) and a pointer to the next node (next).

    The LinkedList class represents the list abstract data type. It consists of a head pointer (head) and a tail pointer (tail). The insert function inserts a new node with the given value at the end of the list. If the list 
    is empty, the new node becomes both the head and the tail. Otherwise, the new node is appended after the current tail, and the tail pointer is updated accordingly. The display function traverses the list, starting from 
    the head, and prints the data of each node. In the main() function, we create an instance of LinkedList named myList. We insert three elements into the list using the insert function, namely 5, 10, and 15. Finally, we call the display function to print the contents 
    of the list, which outputs "5 10 15".

    The example demonstrates the list abstract data type implemented using a linked list. It showcases the insertion operation, where elements are added to the end of the list, preserving the order. The linked list provides 
    efficient insertion and sequential access to elements. It allows for the dynamic storage of elements, as nodes are dynamically allocated during insertion. The list ADT offers flexibility and versatility in managing collections 
    of data, enabling efficient manipulation and traversal of elements.
\end{solution}

\subsection*{Sec. 5.2 - Singly-Linked Lists}

\subsubsection{Singly-Linked List Data Structure}

A singly-linked list is a data structure in which each element, known as a node, contains data and a pointer to the next node in the list. The list is "singly-linked" because it allows traversal in one direction, from the head (the first node) to the tail (the last node). 
Singly-linked lists are dynamic data structures, allowing for efficient insertion and deletion of elements at the beginning or end of the list. However, accessing or modifying elements in the middle of the list can be less efficient due to the need to traverse from the head. 
Singly-linked lists are commonly used when the order of elements matters, and frequent insertions and deletions are expected, but random access is not a primary requirement. They provide a flexible and memory-efficient way to manage and manipulate collections of data in various 
programming scenarios.

\subsubsection{Appending to Singly Linked List}

Appending to a singly-linked list involves adding a new element to the end of the list. To perform this operation, the tail pointer of the list is utilized. If the list is initially empty, the new element becomes both the head and the tail. Otherwise, the tail pointer is updated 
to point to the new element, effectively making it the new tail. This operation is efficient in a singly-linked list since inserting at the end does not require traversing the entire list. By appending elements to a singly-linked list, the list can dynamically grow, maintaining 
the order of elements while enabling efficient insertion of new elements at the tail.

\subsubsection{Prepending to Singly Linked List}

Prepending to a singly-linked list involves adding a new element at the beginning of the list. This operation requires updating the head pointer of the list to point to the new element, making it the new head. If the list is initially empty, the new element becomes both the head 
and the tail. Prepending is an efficient operation in a singly-linked list since it does not require traversing the entire list. By prepending elements to a singly-linked list, the list can dynamically grow while maintaining the order of elements, allowing for efficient insertion 
of new elements at the beginning. This operation is useful in scenarios where the most recent or frequently accessed elements need to be accessed quickly without traversing the entire list.

\begin{solution}[Singly Linked List Example]
    Below is an example of a singly linked list in C++:

    \horizontalline
    
    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* next;
    
        Node(int value) : data(value), next(nullptr) {}
    };
    
    class SinglyLinkedList {
    private:
        Node* head;
        Node* tail;
    
    public:
        SinglyLinkedList() : head(nullptr), tail(nullptr) {}
    
        void append(int value) {
            Node* newNode = new Node(value);
            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else {
                tail->next = newNode;
                tail = newNode;
            }
        }
    
        void prepend(int value) {
            Node* newNode = new Node(value);
            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else {
                newNode->next = head;
                head = newNode;
            }
        }
    
        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };
    
    int main() {
        SinglyLinkedList myList;
    
        myList.append(5);
        myList.append(10);
        myList.append(15);
    
        myList.display();  // Output: 5 10 15
    
        myList.prepend(2);
        myList.prepend(1);
    
        myList.display();  // Output: 1 2 5 10 15
    
        return 0;
    }
    \end{verbatim}

    \horizontalline

    The `SinglyLinkedList' class represents the singly-linked list data structure. It consists of a head pointer (`head') and a tail pointer (`tail'). The `append' function adds a new node with the given value at the end of the list. 
    If the list is empty, the new node becomes both the head and the tail. Otherwise, the new node is appended after the current tail, and the tail pointer is updated accordingly. The `prepend' function adds a new node with the given 
    value at the beginning of the list. If the list is empty, the new node becomes both the head and the tail. Otherwise, the new node is inserted before the current head, and the head pointer is updated. The `display' function traverses 
    the list and prints the data of each node.

    In the `main()' function, we create an instance of `SinglyLinkedList' named `myList'. We append three elements to the list using the `append' function, namely 5, 10, and 15. We then display the contents of the list, which outputs 
    "5 10 15". Next, we prepend two elements to the list using the `prepend' function, namely 2 and 1. Finally, we display the updated contents of the list, which outputs "1 2 5 10 15".

    The example demonstrates the concepts of appending and prepending to a singly-linked list. The `append' operation adds elements at the end, while the `prepend' operation adds elements at the beginning. These operations allow for dynamic 
    growth of the list while preserving the order of elements. By using the appropriate pointers, the list is efficiently updated without the need to traverse the entire list. Singly-linked lists provide flexibility in adding elements at 
    either end, allowing for efficient insertion of new elements in various programming scenarios.
\end{solution}

\subsection*{Sec. 5.3 - List Data Structure}

The list data structure is a fundamental abstract data type that represents a collection of elements. Lists provide a dynamic and flexible way to store and manage data, allowing for efficient insertion, deletion, and retrieval operations. 
The key characteristic of lists is that they maintain the order of elements as they are added or removed. This order can be based on the position of the elements (e.g., positional index) or on the values of the elements themselves.

Lists can be implemented using different underlying data structures, such as arrays or linked lists. Each implementation has its advantages and trade-offs. Arrays provide fast random access to elements but can be less efficient for insertions 
and deletions, especially in the middle of the list, as it requires shifting elements. Linked lists, on the other hand, offer efficient insertions and deletions but require sequential traversal for accessing elements. Linked lists also have 
the flexibility to grow dynamically by allocating memory for new elements as needed.

Lists support various operations to manipulate the elements, including appending, prepending, inserting, deleting, and searching. These operations allow for the modification and rearrangement of elements within the list. Lists can also support 
additional functionality such as sorting, merging, and splitting.

Lists are widely used in computer programming and software development, as they provide an essential building block for many other data structures and algorithms. They are particularly useful in scenarios where the order of elements matters and 
frequent insertions and deletions are expected. Lists are commonly employed in applications involving data processing, task scheduling, file systems, and more.

Overall, the list data structure offers a flexible and efficient way to organize and manage collections of elements, making it a fundamental tool in computer science and programming. It provides a foundation for implementing more complex data 
structures and algorithms, while also serving as a versatile and practical solution for various programming tasks.

\subsection*{Sec. 5.4 - Singly-Linked Lists: Insert}

Inserting in a singly-linked list involves adding a new element at a specific position within the list. This operation requires updating the appropriate pointers to maintain the integrity and order of the list. Insertion can be performed at the 
beginning, in the middle, or at the end of the list. To insert an element at the beginning, the head pointer is updated to point to the new node, while its next pointer is set to the current head. For inserting in the middle, the pointers of the 
adjacent nodes are modified to link the new node appropriately. Inserting at the end involves updating the tail pointer to point to the new node and setting its next pointer to nullptr. Inserting in a singly-linked list is efficient for operations 
that involve updating only a few pointers, allowing for dynamic growth and modification of the list while preserving the order of elements.

\begin{solution}[Singly-Linked List Insert Example]
    Below is an example of inserting into a singly-linked list in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* next;
    
        Node(int value) : data(value), next(nullptr) {}
    };
    
    class SinglyLinkedList {
    private:
        Node* head;
        Node* tail;
    
    public:
        SinglyLinkedList() : head(nullptr), tail(nullptr) {}
    
        void insert(int value, int position) {
            Node* newNode = new Node(value);
    
            if (head == nullptr || position == 0) {
                newNode->next = head;
                head = newNode;
                if (tail == nullptr) {
                    tail = newNode;
                }
            } else {
                Node* current = head;
                int count = 0;
    
                while (current->next != nullptr && count < position - 1) {
                    current = current->next;
                    count++;
                }
    
                newNode->next = current->next;
                current->next = newNode;
    
                if (newNode->next == nullptr) {
                    tail = newNode;
                }
            }
        }
    
        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };
    
    int main() {
        SinglyLinkedList myList;
    
        myList.insert(5, 0);   // Insert 5 at position 0
        myList.insert(10, 1);  // Insert 10 at position 1
        myList.insert(7, 1);   // Insert 7 at position 1
    
        myList.display();  // Output: 5 7 10
    
        return 0;
    }        
    \end{verbatim}

    \horizontalline

    The `SinglyLinkedList' class represents the singly-linked list data structure. It consists of a head pointer (`head') and a tail pointer (`tail'). The `insert' function adds a new node with the given value at the specified position within the 
    list. If the list is empty or the position is 0, the new node becomes the new head, and its next pointer is set to the previous head. If the position is not at the beginning, the function iterates through the list to find the appropriate position. 
    Once found, the new node is inserted by updating the pointers of the previous and next nodes accordingly. The `display' function traverses the list and prints the data of each node.

    In the `main()' function, we create an instance of `SinglyLinkedList' named `myList'. We insert three elements into the list using the `insert' function, with values 5, 10, and 7, respectively, at positions 0, 1, and 1. Finally, we call the `display' 
    function to print the contents of the list, which outputs "5 7 10".

    The example demonstrates the concept of inserting an element at a specific position in a singly-linked list. The `insert' operation allows for dynamic modification of the list by rearranging the pointers of the nodes. By updating the appropriate 
    pointers, the new node is seamlessly integrated into the list while maintaining the order of elements. Singly-linked lists provide an efficient way to insert elements at various positions, enabling flexibility and versatility in managing collections of data.
\end{solution}

\subsection*{Sec. 5.5 - Singly-Linked Lists: Remove}

Removing elements from a singly-linked list involves deleting a node at a specific position or with a particular value. To remove a node at a given position, the pointers of the preceding and following nodes are adjusted to bypass the node being removed, effectively 
removing it from the list. If the node to be removed is the head, the head pointer is updated to point to the next node. Removing a node based on a value requires traversing the list to find the node with the desired value. Once found, the pointers of the preceding 
and following nodes are adjusted to exclude the node with the target value. Removing elements from a singly-linked list is an efficient operation, especially when the position or value to be removed is known, as it involves updating a few pointers rather than shifting 
elements. This flexibility in removing nodes allows for dynamic modification of the list while maintaining the order of the remaining elements.

\begin{solution}[Singly-Linked List Remove Example]
    Below is an example of removing in a singly-linked list in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* next;
    
        Node(int value) : data(value), next(nullptr) {}
    };
    
    class SinglyLinkedList {
    private:
        Node* head;
        Node* tail;
    
    public:
        SinglyLinkedList() : head(nullptr), tail(nullptr) {}
    
        void remove(int position) {
            if (head == nullptr)
                return;
    
            Node* current = head;
    
            if (position == 0) {
                head = head->next;
                delete current;
    
                if (head == nullptr)
                    tail = nullptr;
            } else {
                Node* previous = nullptr;
                int count = 0;
    
                while (current != nullptr && count < position) {
                    previous = current;
                    current = current->next;
                    count++;
                }
    
                if (current != nullptr) {
                    previous->next = current->next;
    
                    if (previous->next == nullptr)
                        tail = previous;
    
                    delete current;
                }
            }
        }
    
        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };
    
    int main() {
        SinglyLinkedList myList;
    
        myList.remove(0);  // No effect, list is empty
    
        myList.display();  // Output: (empty)
    
        myList.insert(5, 0);   // Insert 5 at position 0
        myList.insert(10, 1);  // Insert 10 at position 1
        myList.insert(7, 1);   // Insert 7 at position 1
    
        myList.display();  // Output: 5 7 10
    
        myList.remove(1);  // Remove element at position 1
    
        myList.display();  // Output: 5 10
    
        return 0;
    }        
    \end{verbatim}

    \horizontalline

    The `SinglyLinkedList' class represents the singly-linked list data structure. It consists of a head pointer (`head') and a tail pointer (`tail'). The `remove' function removes a node at the specified position within the list. If the list is empty or the position 
    is out of range, the function does nothing. If the position is 0, the head is updated to the next node, and the original head is deleted. If the position is not 0, the function iterates through the list to find the node at the specified position. Once found, the 
    function updates the pointers of the previous and following nodes to exclude the node being removed and deletes the target node. The `display' function traverses the list and prints the data of each node.

    In the `main()' function, we create an instance of `SinglyLinkedList' named `myList'. We attempt to remove an element from an empty list, which has no effect. We then insert three elements into the list using the `insert' function, with values 5, 10, and 7, respectively, 
    at positions 0, 1, and 1. We display the contents of the list, which outputs "5 7 10". Next, we `remove' the element at position 1 using the remove function. Finally, we display the updated contents of the list, which outputs "5 10" since the element with value 7 has 
    been successfully removed.

    The example demonstrates the concept of removing elements from a singly-linked list. The `remove' operation allows for the dynamic modification of the list by adjusting the pointers of the preceding and following nodes. By updating these pointers, the target node is 
    effectively bypassed and removed from the list while preserving the order of the remaining elements. Removing nodes from a singly-linked list is an efficient operation, as it involves updating a few pointers rather than shifting elements. This flexibility in removing nodes 
    provides practicality and versatility in managing collections of data with varying needs.
\end{solution}