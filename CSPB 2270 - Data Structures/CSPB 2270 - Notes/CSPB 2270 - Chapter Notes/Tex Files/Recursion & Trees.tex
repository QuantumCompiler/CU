\clearpage

\chapter{Week 4}

\section{Recursion \& Trees}

\horizontalline

\subsection{Activiites}
The following are the activities that are planned for Week 4 of this course.
\begin{itemize}
    \item Reading Quiz(s) from last week are due on Monday.
    \item Assignment-2 (Linked List) is due Tuesday.
    \item Read the zyBook chapter(s) assigned and complete the reading quiz(s) by next Monday.
    \item Watch week videos Recursion and the Tree data structure.
    \item Access the GitHub Classroom to get your Assignment-3 repository  (assignment due in two weeks).
\end{itemize}

\subsection{Lectures}
Here are the lectures that can be found for this week:
\begin{itemize}
    \item \href{https://applied.cs.colorado.edu/mod/hvp/view.php?id=45909}{Recursion}
    \item \href{https://applied.cs.colorado.edu/mod/hvp/view.php?id=45910}{Trees}
    \item \href{https://applied.cs.colorado.edu/mod/hvp/view.php?id=45911}{Binary Search Trees}
    \item \href{https://applied.cs.colorado.edu/mod/hvp/view.php?id=45912}{Tree Traversal}
    \item \href{https://applied.cs.colorado.edu/mod/hvp/view.php?id=45913}{BST Operations}
    \item \href{https://applied.cs.colorado.edu/mod/hvp/view.php?id=45914}{BST Remove Operation}
\end{itemize}

\subsection{Programming Assignment}
The programming assignment for Week 4 - \href{https://github.com/cu-cspb-2270-Summer-2023/pa3-RelativiBit}{Binary Search Tree}.

\subsection{Chapter 6 - Recursion}

The first chapter of this week is Chapter 6 - Recursion.

\subsection*{Sec. 6.1 - Recursion: Introduction}

Recursion is a powerful concept in object-oriented programming (OOP) that allows a function or method to call itself during its execution. It involves breaking down a complex problem into smaller, similar subproblems and solving them iteratively 
by invoking the same function within itself. Recursion relies on the concept of a base case, which defines the termination condition to stop the recursive calls. Each recursive call works on a smaller subset of the original problem until the base 
case is reached, at which point the recursion "unwinds" and the results are combined to solve the original problem. Recursion is particularly useful for solving problems that exhibit a recursive structure, such as traversing hierarchical data structures, 
generating permutations or combinations, and implementing algorithms like quicksort or binary search. It offers an elegant and concise way to solve complex problems and can often result in more readable and maintainable code when used appropriately.

\begin{solution}[Recursion Example]
    Below is an example of recursion in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    int factorial(int n) {
    // Base case: factorial of 0 is 1
    if (n == 0) {
        return 1;
    }
    // Recursive case: calculate factorial of n by 
    // multiplying it with factorial of n-1
    return n * factorial(n - 1);
    }

    int main() {
        int number = 5;
        int result = factorial(number);
        std::cout << "Factorial of " << number << " is: " << result << std::endl;
        return 0;
    }
    \end{verbatim}

    \horizontalline

    The example demonstrates the use of recursion to calculate the factorial of a number. The `factorial' function takes an integer `n' as input and recursively calculates the factorial by multiplying `n' with the factorial of `n-1'. The base case is defined as 
    `n == 0', where the function returns 1, indicating the factorial of 0. The recursive case performs successive multiplications until the base case is reached. In the main function, the factorial of the number 5 is calculated using the `factorial' function, and 
    the result is printed. Recursion simplifies the factorial calculation by breaking it down into smaller subproblems until the base case is encountered, offering an elegant and concise solution.
\end{solution}

\subsection*{Sec. 6.2 - Recursive Functions}

Recursive functions in C++ are functions that call themselves during their execution. They allow the solving of complex problems by breaking them down into smaller, simpler subproblems. A recursive function consists of two components: the base case, which defines the 
termination condition to stop the recursion, and the recursive case, where the function calls itself with a modified input. Each recursive call reduces the problem size, bringing it closer to the base case. Recursive functions are particularly useful for solving problems 
with a recursive structure, such as traversing trees or linked lists, generating permutations, or implementing sorting algorithms like merge sort. Proper design and termination conditions are crucial to ensure the recursion does not lead to infinite loops. Recursive functions 
offer a concise and elegant way to solve complex problems by leveraging the power of self-reference and the ability to decompose problems into smaller, manageable parts.

\begin{solution}[Recursive Function Example]
    Below is an example of a recursive function in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    int recursiveSum(int n) {
        // Base case: if n is 1, return 1
        if (n == 1) {
            return 1;
        }
        // Recursive case: calculate sum of n and the sum of integers from 1 to n-1
        return n + recursiveSum(n - 1);
    }
    
    int main() {
        int number = 5;
        int result = recursiveSum(number);
        std::cout << "The sum of integers from 1 to " << number 
        << " is: " << result << std::endl;
        return 0;
    }
    \end{verbatim}

    \horizontalline

    The example demonstrates the use of recursion to calculate the sum of integers from 1 to a given number. The `recursiveSum' function takes an integer `n' as input and recursively calculates the sum by adding `n' to the sum of integers from 1 to `n-1'. The base case is defined 
    as `n == 1', where the function returns 1. The recursive case performs successive additions until the base case is reached. In the main function, the sum of integers from 1 to the number 5 is calculated using the `recursiveSum' function, and the result is printed. Recursive functions 
    provide a concise and elegant solution for problems that can be decomposed into smaller subproblems, allowing for a natural and intuitive implementation.
\end{solution}

\subsection*{Sec. 6.3 - Recursive Algorithm: Search}

\subsubsection{Recursive Search}

A recursive search algorithm is a technique that uses recursion to search for a specific element or value in a data structure. It involves breaking down the search problem into smaller subproblems and recursively searching through each subproblem until the target element is found or until 
the search space is exhausted. The algorithm typically has a base case that defines the termination condition, where it either finds the target element or determines that it does not exist in the data structure. In the recursive case, the algorithm divides the search space into smaller parts 
and recursively applies the search algorithm to each part. Recursive search algorithms are commonly used in tree and graph traversals, as well as in other data structures. They offer a concise and elegant approach to solving search problems by leveraging the power of recursion and decomposition 
of the search space.

\subsubsection{Recursive Search Function}

A recursive search function is an algorithm that uses recursion to search for a specific element or value within a data structure. The function divides the search space into smaller subproblems and recursively applies the search function to each subproblem until the target element is found or the 
search space is exhausted. It typically includes a base case that defines the termination condition, where the function either finds the target element or determines that it does not exist. In the recursive case, the function splits the search space into smaller parts and recursively invokes itself 
on each part. Recursive search functions are commonly used in various scenarios, such as searching elements in trees, linked lists, or arrays. They provide an elegant and intuitive way to solve search problems by decomposing the search space and leveraging the power of recursion to explore and locate 
the desired element efficiently.

\subsubsection{Recursively Searching a Sorted List}

Recursively searching a sorted list involves using a divide-and-conquer approach to find a target element efficiently. The algorithm starts by comparing the target element with the middle element of the list. If they match, the search is successful. If the target is smaller, the algorithm recursively 
searches the left half of the list. If the target is larger, the algorithm recursively searches the right half. This process continues until the target element is found or the search space is reduced to zero. By repeatedly dividing the search space in half, the algorithm eliminates large portions of 
the list at each step, making it highly efficient for large sorted lists. Recursive searching of sorted lists is a commonly used technique, providing a logarithmic time complexity of $\mathcal{O}\log{(n)}$ and offering an efficient way to find elements within sorted data structures.

\begin{solution}[Recursive Search Algorithm Example]
    Below is an example of using a recursive search algorithm in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>
    #include <vector>
    
    int binarySearch(const std::vector<int>& sortedList, int target, 
                    int left, int right) {
        if (left > right) {
            return -1; // Target element not found
        }
    
        int mid = (left + right) / 2;
    
        if (sortedList[mid] == target) {
            return mid; // Target element found
        } else if (sortedList[mid] > target) {
            // Recursively search the left half
            return binarySearch(sortedList, target, left, mid - 1);
        } else {
            // Recursively search the right half
            return binarySearch(sortedList, target, mid + 1, right);
        }
    }
    
    int main() {
        std::vector<int> sortedList = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int target = 7;
        int index = binarySearch(sortedList, target, 0, sortedList.size() - 1);
    
        if (index != -1) {
            std::cout << "Target element found at index: " << index << std::endl;
        } else {
            std::cout << "Target element not found." << std::endl;
        }
    
        return 0;
    }
    \end{verbatim}

    \horizontalline

    The example demonstrates recursive searching in a sorted list using the binary search algorithm. The `binarySearch' function takes a sorted list, target element, and the indices of the left and right boundaries. It recursively divides the search space in half by comparing the target element with the 
    middle element of the current range. If the target matches the middle element, the function returns the index. Otherwise, it recursively searches the left or right half of the range based on the comparison result. The algorithm continues until the target element is found or the search space is reduced 
    to zero. In the main function, a sorted list is defined, and the `binarySearch' function is called to search for the target element. If the target is found, the index is printed; otherwise, a message is displayed indicating that the target element is not found. Recursive searching in a sorted list using 
    the binary search algorithm provides an efficient way to locate elements by repeatedly dividing the search space in half, resulting in a logarithmic time complexity of $\mathcal{O}\log{(n)}$ and making it suitable for large sorted lists.
\end{solution}

\subsection*{Sec. 6.4 - Adding Output Statements for Debugging}

Adding output statements for debugging is a common technique used to track the execution flow and identify issues within a program. By strategically placing print statements or logging statements at key points in the code, developers can observe the values of variables, check the program's state, and trace 
the control flow during runtime. These output statements can help diagnose problems, verify the correctness of algorithms or conditions, and provide insights into the program's behavior. Debugging output statements are especially useful when dealing with complex logic, loops, or conditionals, as they allow 
developers to observe intermediate results and identify any unexpected or erroneous behavior. By selectively adding output statements and analyzing the output, developers can gain a better understanding of the program's execution and effectively debug issues, ultimately leading to more robust and reliable software.

\begin{solution}[Output Statements Example]
    Below is an example of adding output statements for recursion in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    int factorial(int n) {
        std::cout << "Calculating factorial of: " << n << std::endl;
    
        if (n == 0) {
            std::cout << "Base case reached: n = 0" << std::endl;
            return 1;
        }
    
        int result = n * factorial(n - 1);
    
        std::cout << "Factorial of " << n << " is: " << result << std::endl;
    
        return result;
    }
    
    int main() {
        int number = 5;
        int result = factorial(number);
    
        std::cout << "Final result: " << result << std::endl;
    
        return 0;
    }
    \end{verbatim}

    \horizontalline

    The example demonstrates adding output statements for debugging purposes in a recursive function that calculates the factorial of a number. Within the `factorial' function, output statements are strategically placed to track the execution flow. The statements print the current value of `n' before each recursive call, 
    indicating the progress of the calculation. When the base case is reached (i.e., `n' becomes zero), a message is printed to indicate the termination of recursion. After each recursive call, the calculated factorial value for the current `n' is displayed. In the `main' function, the `factorial' function is called with 
    the number 5, and the final result is printed. By observing the output, developers can trace the recursive calls, check the intermediate values of `n', and verify the correctness of the factorial calculation. Adding such output statements for debugging aids in understanding the behavior of recursive functions, identifying 
    any issues or unexpected behavior, and effectively diagnosing problems.
\end{solution}

\subsection*{Sec. 6.5 - Creating a Recursive Function}

Creating a recursive function involves defining a function that calls itself within its own body. Recursive functions are useful when solving problems that can be divided into smaller subproblems of the same nature. The function typically includes a base case, which specifies when the recursion should terminate, and a recursive 
case, which defines the recursive call(s) to solve the problem incrementally. Recursive functions allow for elegant and concise solutions to certain problems, leveraging the power of self-referential calls to break down complex tasks into simpler ones. However, it is important to ensure that recursive functions have well-defined 
termination conditions to avoid infinite recursion and unnecessary resource consumption.

\begin{solution}[Creating a Recusive Function Example]
    Below is an example of creating a recursive function in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    int fibonacci(int n) {
        // Base cases
        if (n == 0)
            return 0;
        if (n == 1)
            return 1;
    
        // Recursive case
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    int main() {
        int n = 6;
        int result = fibonacci(n);
        std::cout << "The " << n << "th Fibonacci number is: " 
        << result << std::endl;
    
        return 0;
    }
    \end{verbatim}

    \horizontalline

    The example demonstrates the creation of a recursive function to calculate the nth Fibonacci number. The `fibonacci' function takes an integer `n' as input and uses recursive calls to compute the Fibonacci number at position `n'. The base cases are defined for `n' equal to 0 and 1, where the function returns the respective Fibonacci 
    numbers. In the recursive case, the function calls itself with `n - 1' and `n - 2' to calculate the previous two Fibonacci numbers and adds them together to determine the current Fibonacci number. In the `main' function, the `fibonacci' function is called with `n = 6', and the result is printed. The recursive nature of the function 
    allows for a concise implementation to calculate Fibonacci numbers, where each number is derived by summing the two previous numbers. Recursive functions are particularly useful in scenarios where a problem can be broken down into smaller instances of the same problem, leading to a more elegant and readable code solution.
\end{solution}

\subsection*{Sec. 6.6 - Recursive Math Functions}

Recursive math functions are functions that utilize recursion to solve mathematical problems. These functions often involve breaking down a complex mathematical problem into smaller subproblems of the same nature, solving each subproblem recursively, and combining the results to obtain the final solution. Recursive math functions are commonly 
used to solve problems such as computing factorials, calculating Fibonacci numbers, exponentiation, or finding combinations and permutations. By leveraging the power of recursion, these functions can provide elegant and concise solutions to mathematical problems, reducing the complexity of the code and improving readability. However, it is 
important to define appropriate base cases and ensure that the recursive calls converge towards the base cases to prevent infinite recursion and ensure termination.

\begin{solution}[Recursive Math Function Example]
    Below is an example of recursive math functions in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    int factorial(int n) {
        // Base case: factorial of 0 is 1
        if (n == 0)
            return 1;
    
        // Recursive case: multiply n by factorial of (n - 1)
        return n * factorial(n - 1);
    }
    
    int main() {
        int number = 5;
        int result = factorial(number);
        std::cout << "The factorial of " << number << " is: " 
        << result << std::endl;
    
        return 0;
    }
    \end{verbatim}

    \horizontalline

    The example demonstrates the use of a recursive math function to calculate the factorial of a given number. The `factorial' function takes an integer `n' as input and recursively multiplies `n' by the factorial of `(n - 1)' until the base case of `n' equal to 0 is reached. The base case specifies that the factorial of 0 is 1. By making recursive 
    calls and breaking down the problem into smaller subproblems, the function calculates the factorial of the given number. In the `main' function, the `factorial' function is called with `number = 5', and the result is printed. Recursive math functions provide an elegant and concise way to solve mathematical problems by decomposing them into smaller, 
    manageable tasks. They allow for a more intuitive representation of the problem and often result in more readable code.
\end{solution}

\subsection*{Sec. 6.7 - Recursive Exploration of all Possibilities}

Exploring all possibilities using recursion involves designing a recursive function to systematically generate and explore all possible combinations, permutations, or configurations of a given problem. The recursive function typically explores different choices or options at each step and recursively explores all subsequent possibilities until a base 
case is reached. The base case defines when the recursion should terminate, and the function returns or processes the final result. By exhaustively exploring all possibilities through recursion, we can systematically analyze and solve problems that involve generating or examining all potential outcomes. Recursive exploration of possibilities is particularly 
useful in tasks such as generating permutations, solving combinatorial problems, backtracking, or searching through a decision tree. However, it is essential to design the recursive function with care, defining appropriate base cases and ensuring that the recursive calls converge towards the base cases to avoid infinite recursion and unnecessary computation.

\begin{solution}[Recursive Exploration Example]
    Below is an example of recursive exploration in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>
    #include <vector>
    
    void generateSubsets(const std::vector<int>& set, 
                        std::vector<int>& currentSubset, int index) {
        // Base case: when we reach the end of the set
        if (index == set.size()) {
            // Process the current subset
            for (int num : currentSubset) {
                std::cout << num << " ";
            }
            std::cout << std::endl;
            return;
        }
    
        // Recursive case: explore two possibilities 
        // - include the current element or exclude it
        // Include the current element
        currentSubset.push_back(set[index]);
        generateSubsets(set, currentSubset, index + 1);
    
        // Exclude the current element
        currentSubset.pop_back();
        generateSubsets(set, currentSubset, index + 1);
    }
    
    int main() {
        std::vector<int> set = {1, 2, 3};
        std::vector<int> currentSubset;
        generateSubsets(set, currentSubset, 0);
    
        return 0;
    }
    \end{verbatim}

    \horizontalline

    The example demonstrates how to use recursion to explore all possible subsets of a given set. The `generateSubsets' function takes the set, a vector to store the current subset, and the current index as parameters. The base case is when the index reaches the end of the set, where the current subset is processed and printed. 
    In the recursive case, the function explores two possibilities at each step: including the current element in the subset or excluding it. By making recursive calls with updated parameters, the function generates all possible subsets by systematically exploring different combinations of elements. In the `main' function, the 
    `generateSubsets' function is called with a set of \{1, 2, 3\}, and all the possible subsets are printed. Recursive exploration of all possibilities allows us to examine and generate various configurations or combinations efficiently.
\end{solution}

\subsection*{Sec. 6.8 - Stack Overflow}

Stack overflow in recursion occurs when the recursive function consumes all available space on the call stack, leading to a runtime error. This typically happens when the recursion does not reach a base case or termination condition, causing an infinite recursion loop. As each recursive function call pushes a new frame onto the 
call stack, repeated recursive calls without proper termination can exhaust the available stack space. This results in a stack overflow error, where the program is unable to allocate more memory on the stack to accommodate additional function calls. To prevent stack overflow, it is crucial to ensure that recursive functions have 
well-defined base cases and termination conditions that allow the recursion to stop. Additionally, tail recursion and iterative approaches can be considered to optimize recursive algorithms and avoid stack overflow issues.

\begin{solution}[Stack Overflow Example]
    Below is an example of stack overflow in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    void recursiveFunction() {
        recursiveFunction();  // Recursive call without a base case
    }
    
    int main() {
        recursiveFunction();
    
        return 0;
    }
    \end{verbatim}

    \horizontalline

    In this example, the `recursiveFunction' is called without a base case or termination condition. As a result, the function enters into an infinite recursion loop, continuously making recursive calls without any stopping condition. Eventually, the recursive calls consume all available space on the call stack, leading to a stack 
    overflow error. When executed, the program encounters a runtime error and terminates due to the stack overflow caused by the infinite recursion. It serves as a reminder of the importance of defining proper base cases or termination conditions in recursive functions to avoid stack overflow errors and ensure the termination of the recursion.
\end{solution}

\subsection*{Sec. 6.9 - Recursively Output Permutations}

Recursively outputting permutations involves generating and printing all possible arrangements of a given set of elements using a recursive approach. The algorithm works by swapping elements in the set, fixing one element at a time, and recursively permuting the remaining elements. At each step, the algorithm explores different choices by swapping 
elements and proceeds with recursive calls until a base case is reached. The base case occurs when only one element remains, indicating that a permutation has been formed. The algorithm then outputs the current permutation. By systematically generating permutations through recursion, all possible arrangements of the elements are explored and printed. 
However, it is essential to handle duplicate elements and ensure proper termination of the recursion to avoid unnecessary computations and infinite recursion loops.

\begin{solution}[Recursively Output Permutations Example]
    Below is an example of recursively outputting permutations in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>
    #include <vector>
    
    void generatePermutations(std::vector<int>& nums, int index) {
        // Base case: when all elements have been fixed
        if (index == nums.size() - 1) {
            for (int num : nums) {
                std::cout << num << " ";
            }
            std::cout << std::endl;
            return;
        }
    
        // Recursive case: generate permutations by fixing one element at a time
        for (int i = index; i < nums.size(); ++i) {
            std::swap(nums[index], nums[i]);
            generatePermutations(nums, index + 1);
            std::swap(nums[index], nums[i]);  // Restore the original order
        }
    }
    
    int main() {
        std::vector<int> nums = {1, 2, 3};
        generatePermutations(nums, 0);
    
        return 0;
    }
    \end{verbatim}

    \horizontalline

    This example demonstrates how to recursively output permutations of a given set of numbers. The `generatePermutations' function takes a vector of numbers and the current index as parameters. In the base case, when the index reaches the last element, the function outputs the current permutation. In the recursive case, the function swaps the current 
    element with all subsequent elements, fixes it, and recursively generates permutations for the remaining elements. By systematically swapping elements and making recursive calls, the function generates all possible permutations of the given set. In the `main' function, the `generatePermutations' function is called with a set of \{1, 2, 3\}, and all 
    the permutations are printed. The example demonstrates how recursion can be used to generate and output permutations efficiently by exploring different choices and combinations of elements.
\end{solution}

\subsection*{Sec. 6.10 - Recursive Definitions}

\subsubsection{Recursive Algorithms}

Recursive algorithms are algorithms that solve a problem by breaking it down into smaller, simpler instances of the same problem. They employ the concept of self-reference, where a function calls itself to solve a smaller subproblem, eventually reaching a base case that does not require further recursion. Recursive algorithms follow the divide-and-conquer 
approach, where a larger problem is divided into smaller, more manageable subproblems, and the results are combined to obtain the final solution. These algorithms are often elegant and concise, as they leverage the power of recursion to solve complex problems by solving smaller versions of themselves. However, it is essential to ensure that recursive algorithms 
have well-defined base cases, proper termination conditions, and avoid unnecessary recomputation to prevent infinite recursion and optimize performance.

\subsubsection{Recursive Functions}

Recursive functions are functions that call themselves within their own definition to solve a problem by breaking it down into smaller, simpler instances of the same problem. They allow for the repetition of a specific set of instructions until a certain condition is met, known as the base case. Recursive functions leverage the concept of self-reference to solve 
complex problems by reducing them to simpler subproblems. Each recursive call operates on a smaller portion of the problem until reaching the base case, where the recursion stops and the results are combined to obtain the final solution. Recursive functions are widely used when dealing with problems that exhibit a recursive structure, as they provide an elegant 
and intuitive way to tackle such problems. However, it is crucial to define proper base cases and ensure termination conditions to prevent infinite recursion and ensure the correctness and efficiency of recursive functions.

\subsection*{Sec. 6.11 - Recursive Algorithms}

Popular recursive algorithms include the factorial function, which calculates the product of all positive integers up to a given number by recursively multiplying the number with the factorial of its predecessor until reaching the base case of 0 or 1. The Fibonacci sequence is another well-known recursive algorithm, where each number in the sequence is the sum of 
the two preceding numbers, with the base cases of 0 and 1. The recursive implementation of quicksort divides the input array into subarrays based on a chosen pivot, recursively sorting the subarrays until reaching subarrays of size 1 or 0. The binary search algorithm uses recursion to efficiently search for a target element in a sorted array by recursively dividing 
the array into halves and discarding the half that does not contain the target. These are just a few examples of recursive algorithms, which demonstrate the power and versatility of recursion in solving various computational problems by breaking them down into simpler instances.