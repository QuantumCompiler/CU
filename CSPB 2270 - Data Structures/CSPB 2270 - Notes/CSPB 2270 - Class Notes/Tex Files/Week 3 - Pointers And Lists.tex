\clearpage

\chapter{Week 3}

\section{Pointers \& Lists}

\horizontalline

\subsection{Activites}
The following are the activities that are planned for Week 3 of this course.
\begin{itemize}
    \item Reading Quiz(s) from last week are due on Monday.
    \item Assignment-1 (Vector10) is due Tuesday.
    \item Read the zyBook chapter(s) assigned and complete the reading quiz(s) by next Monday.
    \item Read the C++ refresher or access other resources to improve your skills.
    \item Watch videos on Pointers and Linked Lists.
    \item Implement the examples In this week videos on your Jupytherhub machine.
    \item Watch the video about Assignment-2 (Linked List).
    \item Access the GitHub Classroom to get your Assignment-2 repository  (assignment due next Tuesday).
\end{itemize}

\subsection{Lectures}
Here are the lectures that can be found for this week:
\begin{itemize}
    \item \href{https://www.youtube.com/watch?v=PLQK95HoMR8}{Pointers in C/C++}
    \item \href{https://www.youtube.com/watch?v=r1gCuzMQWP8}{Pass Objects by Value / Reference}
    \item \href{https://www.youtube.com/watch?v=HeJEOz7CFUU}{Stack vs. Heap}
    \item \href{https://www.youtube.com/watch?v=lnFReYlnNYw}{Smart Pointers in C++}
    \item \href{https://www.youtube.com/watch?v=4lyTPdZwp0w}{shared\_ptr Examples}
    \item \href{https://www.youtube.com/watch?v=8uPA8BpaRu4}{Linked List}
\end{itemize}

\subsection{Programming Assignment}
The programming assignment for Week 3 - \href{https://github.com/cu-cspb-2270-Summer-2023/pa2-RelativiBit}{Linked List}.

\subsection{Chapter 4 - Pointers}

The first chapter of this week is Chapter 4 - Pointers.

\subsection*{Sec. 4.1 - Why Pointers?}

Pointers are variables that store memory addresses as their values. They play a crucial role in programming languages, allowing direct manipulation and access to memory locations. Pointers enable efficient data manipulation 
by providing a way to refer to and modify data indirectly, rather than making unnecessary copies. They are especially useful in data structures and algorithms, as they facilitate dynamic memory allocation, efficient traversal 
of linked data structures, and enable the passing of values by reference. However, working with pointers requires careful management to avoid memory leaks and undefined behavior, making them a fundamental concept to understand 
in programming

\begin{solution}[Pointers Example]
    Below is an example of pointers in C++:

    \horizontalline

    \begin{verbatim}    
    #include <iostream>

    int main() {
        int value = 42;
        int* pointer = &value;
    
        std::cout << "Value: " << value << std::endl;
        std::cout << "Memory address of value: " << &value << std::endl;
        std::cout << "Pointer value: " << pointer << std::endl;
        std::cout << "Dereferenced pointer value: " << *pointer << std::endl;
    
        *pointer = 99;
    
        std::cout << "Updated value: " << value << std::endl;
    
        return 0;
    }
        \end{verbatim}
    
        \horizontalline
        
    In this code snippet, we declare a variable value and initialize it with the value 42. We then declare a pointer variable pointer of type int* (pointer to an integer) and assign it the memory address of the value variable using 
    the \& (address-of) operator. By dereferencing the pointer with *pointer, we can access the value stored at that memory address, which is the value of value. We can modify the value of value indirectly by assigning a new value 
    to *pointer. In this case, we update it to 99. Finally, we print the original and updated values to demonstrate how modifying the value through the pointer affects the original variable.
\end{solution}

\subsection*{Sec. 4.2 - Pointer Basics}

\subsubsection{Pointer Variables}

In object-oriented programming (OOP), pointer variables serve as essential tools for managing objects and dynamic memory allocation. Pointers allow for the creation and manipulation of objects indirectly by holding the memory address 
of the object instead of its actual value. This enables efficient memory usage and facilitates complex data structures and polymorphism. By using pointer variables, objects can be accessed and modified across different scopes and functions, 
providing flexibility and modularity in OOP. Additionally, pointers play a crucial role in managing resources and memory deallocation through techniques such as garbage collection or smart pointers. Understanding pointer variables in OOP 
is vital for effective memory management and advanced object manipulation.

\subsubsection{Dereferencing a Pointer}

Dereferencing pointers is the process of accessing the value stored at the memory address pointed to by a pointer variable. By using the dereference operator (*) in programming languages like C++ or C, we can retrieve and manipulate the actual 
value associated with the pointer. Dereferencing allows us to read or modify the data pointed to by the pointer, enabling direct access and manipulation of objects, arrays, or structures in memory. Care must be taken when dereferencing pointers 
to ensure that they are pointing to valid memory locations, as accessing invalid or uninitialized memory can lead to unpredictable behavior or runtime errors. Understanding how to properly dereference pointers is crucial for efficient and correct 
utilization of pointer variables in programming.

\subsubsection{Null Pointers}

Null pointers are special pointers that do not point to a valid memory location. They are used to indicate that a pointer variable does not currently refer to any object or memory address. In programming languages like C++ or C, a null pointer is 
typically represented by the value 0 or nullptr. Null pointers are useful in several scenarios, such as initializing pointers before they are assigned valid addresses, checking for the absence of a valid object reference, or signaling the end of 
data structures like linked lists. However, accessing or dereferencing a null pointer can lead to runtime errors like segmentation faults, so it is important to check for nullness before using a pointer to avoid such issues. Understanding null 
pointers is crucial for handling pointer variables and ensuring proper memory safety in programming.

\begin{solution}[Pointer Basics Example]
    Below is an example of pointer basics in C++:
    

    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>

    int main() {
        int* ptr = nullptr;  // Initializing pointer to null
    
        if (ptr == nullptr) {
            std::cout << "Pointer is null!" << std::endl;
        } else {
            std::cout << "Pointer is not null!" << std::endl;
        }
    
        int value = 42;
        ptr = &value;  // Assigning valid memory address to the pointer
    
        if (ptr != nullptr) {
            std::cout << "Pointer is not null!" << std::endl;
            std::cout << "Dereferenced value: " << *ptr << std::endl;
        }
    
        return 0;
    }
        \end{verbatim}
    
        \horizontalline

    In this code, we start by initializing a pointer variable `ptr' to `nullptr', indicating that it does not currently point to a valid memory address. We then check if the pointer is null using the `==' comparison operator and print a 
    corresponding message. Next, we declare an integer variable `value' and assign it the value 42. We assign the memory address of `value' to the pointer `ptr' using the address-of operator `\&'. After verifying that the pointer is not 
    null, we dereference it using the `*' operator to access the value stored at the memory address pointed to by `ptr'. Finally, we print the dereferenced value

    In this example, we demonstrate the use of null pointers to indicate the absence of a valid memory address. We initialize the pointer to null, check its nullness, and then assign it a valid address. By dereferencing the pointer, we 
    retrieve the value stored in the memory location pointed to by the pointer. The example highlights the importance of checking for nullness before accessing or dereferencing pointers to avoid runtime errors. Understanding and properly 
    handling null pointers is crucial for ensuring memory safety and preventing unexpected behavior in C++ programs.
\end{solution}

\subsection*{Sec. 4.3 - Operators, new, delete, and The Member Access}

\subsubsection{The `new' Operator}

In C++, the `new' operator is used to dynamically allocate memory for objects or data structures at runtime. It returns a pointer to the allocated memory, allowing us to initialize and work with objects that reside in the heap rather than 
the stack. The `new' operator is followed by the type of the object being allocated, and it automatically handles memory allocation and initialization. This allows for dynamic memory management and flexibility in creating objects whose size 
or lifetime may not be known at compile-time. It is important to pair the `new' operator with the corresponding `delete' or `delete[]' operator to deallocate the memory and avoid memory leaks. Proper understanding and usage of the `new' 
operator are essential for managing dynamic memory allocation and object creation in C++ programs.

\subsubsection{Member Access Operator}

In programming languages like C++ and C\#, the member access operator (->) is used to access members (variables or functions) of an object through a pointer to that object. It provides a convenient way to interact with objects when working 
with pointers, allowing access to the members of the object without dereferencing the pointer explicitly. By using the member access operator, we can access and modify the object's members, invoke member functions, or retrieve values stored 
in member variables. This operator simplifies the syntax and readability when working with objects through pointers, enabling seamless interaction with the underlying object's members and behavior. Understanding and correctly utilizing the 
member access operator is crucial when working with objects through pointers in object-oriented programming languages.

\subsubsection{The `delete' Operator}

In C++ and similar languages, the `delete' operator is used to deallocate memory that was previously allocated dynamically using the `new' operator. It is used to free the memory occupied by objects or arrays created with `new', ensuring 
efficient memory management. When `delete' is applied to a single object, the memory occupied by that object is released. When `delete[]' is used, it is used to deallocate memory allocated for arrays. By properly deallocating memory with 
the `delete' operator, we prevent memory leaks and improve the overall performance of our programs. It is important to note that the `delete' operator should only be used for memory that was dynamically allocated with `new'. Using `delete' 
on a non-dynamically allocated or previously freed memory can lead to undefined behavior and program crashes. Understanding how to correctly apply the `delete' operator is crucial for effective memory management in C++ programs.

\begin{solution}[Pointer Operators Example]
    Below is an example of pointer operators in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>
    
    int main() {
        int* ptr = new int;  // Dynamically allocate memory for an integer
    
        *ptr = 42;  // Assign a value to the dynamically allocated memory
    
        std::cout << "Dynamically allocated value: " << *ptr << std::endl;
    
        delete ptr;  // Deallocate the dynamically allocated memory
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline

    In this code, we use the `new' operator to dynamically allocate memory for an integer. The `new' operator allocates memory from the heap and returns a pointer to the allocated memory. We assign the address of this memory to the 
    pointer variable `ptr'. We then assign the value 42 to the memory location pointed to by `ptr' using the dereference operator `*ptr'. Finally, we print the value stored in the dynamically allocated memory using `std::cout'
    
    To properly manage memory and prevent memory leaks, we use the `delete' operator to deallocate the dynamically allocated memory when we no longer need it. In this example, we deallocate the memory pointed to by `ptr' using `delete ptr'. 
    This frees up the memory for reuse by the system. It is essential to pair every `new' operation with a corresponding `delete' operation to avoid memory leaks and ensure efficient memory management
\end{solution}

\subsection*{Sec. 4.4 - String Functions With Pointers}

\subsubsection{C String Library Functions}

The C string library functions provide a set of built-in functions for working with null-terminated strings in the C programming language. These functions allow for efficient manipulation, searching, comparison, and copying of strings. 
Some commonly used C string library functions include `strlen()' to calculate the length of a string, `strcpy()' and `strncpy()' to copy strings, `strcmp()' and `strncmp()' to compare strings, `strcat()' and `strncat()' to concatenate 
strings, and `strstr()' to search for a substring within a string. These functions provide powerful tools for handling strings in C, making string manipulation and processing tasks more convenient and efficient. Understanding and utilizing 
the C string library functions are essential for effective string handling in C programs.

\subsubsection{C String Search Functions}

C string search functions are part of the C string library and provide efficient mechanisms for searching substrings within null-terminated strings. These functions offer ways to locate occurrences of specific characters or entire substring 
patterns within a larger string. Commonly used C string search functions include `strchr()' to find the first occurrence of a character, `strrchr()' to find the last occurrence of a character, `strstr()' to locate the first occurrence of a 
substring, and `strpbrk()' to search for any character from a set within a string. These functions simplify the process of searching and locating specific patterns within strings, enabling efficient text processing and manipulation in C 
programming. Understanding and utilizing C string search functions are essential for tasks such as parsing, pattern matching, and text analysis in C programs.

\begin{solution}[C String Functions Example]
    Below is an example of C string functions that involve pointers:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <stdio.h>
    #include <string.h>
    
    int main() {
        char str[] = "Hello, World!";
        char *ptr;
    
        ptr = strchr(str, 'W');
        if (ptr != NULL) {
            printf("Found: %s\n", ptr);
        } else {
            printf("Not found!\n");
        }
    
        ptr = strstr(str, "World");
        if (ptr != NULL) {
            printf("Found: %s\n", ptr);
        } else {
            printf("Not found!\n");
        }
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline

    In this code, we declare a null-terminated string `str' containing the text "Hello, World!". We then use the `strchr()' function to search for the first occurrence of the character 'W' within the string `str'. If the character is found, `strchr()' 
    returns a pointer to the first occurrence of 'W', which we assign to the pointer variable `ptr'. We then check if `ptr' is not `NULL' and print the result accordingly. Next, we use the `strstr()' function to search for the first occurrence of the 
    substring "World" within `str'. If the substring is found, `strstr()' returns a pointer to the start of the substring, which we assign to `ptr'. Again, we check if `ptr' is not `NULL' and print the result
    
    This example demonstrates how C string search functions can be used to locate specific characters or substrings within a larger string. By utilizing functions like `strchr()' and `strstr()', we can easily search for patterns and retrieve pointers 
    to the locations of the found substrings within the original string. These C string search functions provide powerful tools for text processing, pattern matching, and string manipulation in C programming, making it easier to perform various tasks 
    such as searching, parsing, and extracting information from strings
\end{solution}

\subsection*{Sec. 4.5 - A First Linked List}

Linked lists are a fundamental data structure used in computer science and programming to store and manage collections of data. A linked list is composed of nodes, where each node contains a value and a reference to the next node in the list. Unlike 
arrays, linked lists do not require contiguous memory allocation, enabling dynamic memory allocation and efficient insertion and deletion operations. Linked lists offer flexibility in size and structure, allowing for efficient insertion and removal of 
elements at any position. However, accessing elements in a linked list requires traversing through the list sequentially, making it less efficient for random access compared to arrays. Overall, linked lists are valuable for scenarios that involve frequent 
insertions or removals, dynamic size requirements, or situations where efficient memory utilization is essential.

\begin{solution}[Linked List Example]
    Below is an example of linked lists in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>
    
    struct Node {
        int data;
        Node* next;
    };
    
    class LinkedList {
    private:
        Node* head;
    
    public:
        LinkedList() : head(nullptr) {}
    
        void insert(int value) {
            Node* newNode = new Node;
            newNode->data = value;
            newNode->next = head;
            head = newNode;
        }
    
        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };
    
    int main() {
        LinkedList list;
    
        list.insert(5);
        list.insert(10);
        list.insert(15);
        list.insert(20);
    
        list.display();
    
        return 0;
    }
    \end{verbatim}
    \horizontalline
    
    In this code, we define a `Node' struct that represents a single node in the linked list. Each node contains a data field to hold the value and a `next' pointer to refer to the next node in the list. We then define a `LinkedList' class that has a `head' 
    pointer as a private member, which points to the first node in the list
    
    The `LinkedList' class provides two member functions. The `insert()' function inserts a new node at the beginning of the list. It creates a new node, assigns the given value to its `data' field, and updates the `next' pointer to point to the current 
    head. The `head' pointer is then updated to point to the newly inserted node. The `display()' function traverses the linked list and prints the values of each node. It starts from the head and continues moving to the next node until reaching the end 
    (i.e., when the `next' pointer is `nullptr'). In the `main()' function, we create an instance of the `LinkedList' class, insert several values into the list, and then call the `display()' function to print the values
    
    This example showcases a basic implementation of a linked list in C++. Linked lists are dynamic data structures that provide efficient insertion and deletion operations, making them suitable for scenarios where frequent modifications to the list are 
    required. By utilizing pointers to link nodes, linked lists offer flexibility and efficient memory utilization compared to other data structures like arrays. Understanding and utilizing linked lists are essential for managing and manipulating collections 
    of data in various programming scenarios
\end{solution}

\subsection*{Sec. 4.6 - Memory Regions, Heap / Stack}

In computer programming, memory regions are areas of memory that serve different purposes in managing data. The static memory region, also known as the global memory, stores static and global variables that are allocated at compile-time and have a fixed 
lifetime throughout the program execution. The stack memory region is used for storing local variables, function call frames, and other runtime data. It operates in a Last-In-First-Out (LIFO) manner, where memory is allocated and deallocated as functions 
are called and return. The heap memory region is a dynamically allocated memory area that is used for managing dynamic memory at runtime. It allows for dynamic allocation and deallocation of memory using mechanisms such as `new' and `delete' or `malloc()' 
and `free()'. The heap is more flexible than the stack and can be used to allocate memory for objects whose size or lifetime is not known at compile-time. Understanding the distinctions between static memory, stack memory, and heap memory is crucial for 
efficient memory management and proper allocation of resources in programming.

\begin{solution}[Memory Regions Example]
    Below is an example of memory regions in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>

    // Static memory region - global variable
    int globalVariable = 10;
    
    void stackFunction() {
        // Stack memory region - local variable
        int stackVariable = 20;
        std::cout << "Stack variable: " << stackVariable << std::endl;
    }
    
    int main() {
        // Static memory region - global variable
        std::cout << "Global variable: " << globalVariable << std::endl;
    
        stackFunction();
    
        // Heap memory region - dynamically allocated memory
        int* heapVariable = new int(30);
        std::cout << "Heap variable: " << *heapVariable << std::endl;
        delete heapVariable;
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline
    
    In this code, we demonstrate the different memory regions: static memory, stack memory, and heap memory. The `globalVariable' is allocated in the static memory region and has a global scope, accessible throughout the program. We print its value in 
    the `main()' function
    
    The `stackFunction()' represents a function, and any local variables declared inside it, such as `stackVariable', are allocated in the stack memory region. These variables have a limited lifetime within the scope of the function. We print the value 
    of `stackVariable' inside the function. Next, we allocate memory dynamically on the heap memory region using the `new' operator. We assign a value of 30 to `heapVariable' and print its value. It is important to note that memory allocated on the heap 
    must be deallocated using the `delete' operator to prevent memory leaks. We deallocate the memory at the end of `main()' using `delete'
    
    In summary, this example illustrates the distinctions between static memory, stack memory, and heap memory in C++. Static memory is used for global variables with a fixed lifetime, while stack memory is used for local variables within functions. Stack 
    memory allocation and deallocation are handled automatically as functions are called and return. Heap memory allows for dynamic memory allocation and deallocation using `new' and `delete', providing flexibility for objects with unknown size or lifetime. 
    Understanding these memory regions is crucial for efficient memory management and proper utilization of resources in C++ programs
\end{solution}

\subsection*{Sec. 4.7 - Memory Leaks}

Memory leaks occur when dynamically allocated memory is not properly deallocated or released after it is no longer needed. In programming, memory leaks can happen when the programmer forgets to free memory using the appropriate deallocation mechanisms, such 
as `delete' in C++ or `free()' in C. As a result, the allocated memory remains inaccessible, leading to a gradual accumulation of unused memory over time. Memory leaks can cause programs to consume excessive memory, leading to degraded performance, increased 
resource usage, and potentially causing the program to crash or terminate unexpectedly. Detecting and fixing memory leaks is crucial for efficient memory management, and it involves identifying and releasing dynamically allocated memory when it is no longer 
required, thus preventing unnecessary memory consumption and maintaining the stability and performance of the program.

\begin{solution}[Memory Leak Example]
    Below is an example of a memory leak in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>

    void memoryLeak() {
        int* ptr = new int(42);  // Dynamically allocate memory
    
        // The following line is missing the deallocation step
        // delete ptr;  // Uncommenting this line will fix the memory leak
    }
    
    int main() {
        memoryLeak();
    
        // More code...
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline

    In this code, we have a function `memoryLeak()' that demonstrates a memory leak scenario. Inside this function, we dynamically allocate memory using the `new' operator to create an integer with a value of 42 and assign it to the pointer variable `ptr'. 
    However, the crucial step of deallocating the dynamically allocated memory is missing. The `delete' operator, which would free the memory, is commented out in the code
    
    When `memoryLeak()' is called, memory is allocated for the integer but never released, resulting in a memory leak. The memory leak occurs because the program loses track of the allocated memory, making it inaccessible for future use. In this example, 
    the memory leak is intentional to demonstrate the concept, but in real-world scenarios, memory leaks are typically unintentional
    
    Memory leaks can cause the program to consume more and more memory over time, potentially leading to performance issues, resource exhaustion, or program crashes. Detecting and fixing memory leaks involves being diligent in deallocating dynamically 
    allocated memory using the appropriate deallocation mechanisms (`delete' in C++). By ensuring proper memory management, programs can avoid unnecessary memory consumption and maintain stability and efficiency
\end{solution}

\subsection*{Sec. 4.8 - Destructor}

Destructors are special member functions in object-oriented programming languages like C++ that are automatically called when an object is destroyed or goes out of scope. They have the same name as the class, preceded by a tilde (\~). Destructors are 
primarily used to clean up resources allocated by the object, such as releasing dynamically allocated memory or closing files or connections. They are particularly useful for ensuring proper resource management and preventing memory leaks or resource 
leaks. When an object is no longer needed, either because it goes out of scope or is explicitly deleted, the destructor is automatically invoked. The destructor allows the object to perform any necessary cleanup operations, freeing up resources and 
maintaining the integrity of the program. Understanding and implementing destructors appropriately is crucial for effective resource management and maintaining the overall robustness and efficiency of object-oriented programs.

\begin{solution}[Destructors Example]
    Below is an example of destructors in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>

    class Resource {
    private:
        int* data;
    
    public:
        Resource() {
            data = new int[10];
            std::cout << "Resource acquired." << std::endl;
        }
    
        ~Resource() {
            delete[] data;
            std::cout << "Resource released." << std::endl;
        }
    
        // Other member functions...
    };
    
    int main() {
        Resource myResource;
        // ...do some operations with myResource
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline

    In this code, we have a class `Resource' that manages a dynamically allocated array `data'. The constructor of the class, `Resource()', is responsible for acquiring the resource by allocating memory using the `new' operator. In this case, we allocate an 
    array of integers with a size of 10. Within the constructor, we display a message to indicate that the resource has been acquired
    
    The crucial aspect is the destructor, `~Resource()'. It is automatically invoked when the object of the `Resource' class goes out of scope, which happens when the `main()' function ends. The destructor takes care of releasing the allocated memory using 
    the `delete[]' operator to free the array. We also display a message in the destructor to indicate that the resource has been released. In the `main()' function, we create an object `myResource' of the `Resource' class. When `main()' finishes executing, 
    the `myResource' object goes out of scope, causing the destructor to be automatically called. As a result, the allocated memory is properly deallocated, ensuring efficient resource management
    
    The example illustrates the usage of a destructor in C++. Destructors are essential for cleaning up resources and performing necessary cleanup operations when an object is no longer needed. By implementing a destructor, developers can ensure proper resource 
    management, prevent memory leaks, and maintain the overall robustness and efficiency of their programs
\end{solution}

\subsection*{Sec. 4.9 - Copy Constructors}

Copy constructors are special member functions in object-oriented programming languages like C++ that are used to create a new object as a copy of an existing object of the same class. The copy constructor is invoked when a new object is initialized from an 
existing object, either by direct initialization or by passing an object as a function argument by value. It performs a member-wise copy of the data from the source object to the newly created object. Copy constructors are particularly useful when working with 
dynamically allocated memory or complex objects that require deep copying. By defining a custom copy constructor, developers can ensure that the new object has its own copy of the data, preventing unintended side effects due to shallow copying. Understanding 
and implementing copy constructors properly is crucial for correct object initialization and avoiding unexpected object state modifications when working with objects in C++.

\begin{solution}[Copy Constructor Example]
    Below is an example of copy constructors in C++:
    
    \horizontalline
    
    \begin{verbatim}   
        #include <iostream>
    
    class Car {
    private:
        std::string brand;
    
    public:
        Car(const std::string& carBrand) : brand(carBrand) {}
    
        // Copy constructor
        Car(const Car& other) : brand(other.brand) {
            std::cout << "Copy constructor called." << std::endl;
        }
    
        void displayBrand() {
            std::cout << "Brand: " << brand << std::endl;
        }
    };
    
    int main() {
        Car car1("Toyota");
        Car car2 = car1;  // Copy constructor is invoked here
    
        car1.displayBrand();
        car2.displayBrand();
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline
    
    In this code, we have a `Car' class that represents a car object with a `brand' attribute. The constructor `Car(const std::string\& carBrand)' initializes the `brand' attribute with the provided `carBrand' value
    
    The important aspect is the copy constructor `Car(const Car\& other)', which is invoked when a new `Car' object is created as a copy of an existing `Car' object. In the `Car' class, the copy constructor performs a member-wise copy of the `brand' attribute 
    from the source object to the newly created object. In this example, we also include a message to indicate when the copy constructor is called. In the `main()' function, we create an object `car1' with the brand "Toyota". Then, we initialize `car2' using 
    the copy constructor by assigning `car1' to `car2'. This invokes the copy constructor, creating a new `Car' object `car2' as a copy of `car1'. Afterward, we call the `displayBrand()' function on both `car1' and `car2' to verify that they hold the same brand value.
    
    The example demonstrates the usage of copy constructors in C++. Copy constructors are useful for creating new objects that are copies of existing objects, ensuring the proper initialization of member variables. By defining a copy constructor, developers 
    can perform a deep copy of data, preventing unintended side effects and maintaining the integrity of the copied object. Understanding and implementing copy constructors correctly are crucial for handling object copies and ensuring the expected behavior of 
    objects in C++ programs.
\end{solution}

\subsection*{Sec. 4.10 - Copy Assignment Operator}

\subsubsection{Default Assignment Operator Behavior}

In C++, the default assignment operator (`operator=') is a member function automatically generated by the compiler if no custom assignment operator is provided in the class. It performs a member-wise assignment, copying each member variable from the source object to 
the target object. The default assignment operator assigns the values of the member variables of the source object to the corresponding member variables of the target object. However, it does a shallow copy, which means that if the class contains dynamically allocated 
memory or resources, a shallow copy would simply copy the memory addresses rather than creating independent copies. This can lead to issues when multiple objects share the same resources. Therefore, if a class contains dynamically allocated memory or resources, it is 
recommended to define a custom assignment operator to perform a deep copy, ensuring that each object has its own separate copy of the resources.

\subsubsection{Overloading the Assignment Operator}

In C++, the assignment operator (`operator=') can be overloaded to provide a custom implementation for assigning one object to another of the same class. Overloading the assignment operator allows for more control over how the assignment operation is performed, 
especially when dealing with complex objects or dynamically allocated memory. By providing a custom assignment operator, developers can define their own rules for copying or transferring data between objects. This can involve deep copying of dynamically allocated memory, 
handling of resources, or any other necessary operations to ensure proper assignment semantics. Overloading the assignment operator enables greater flexibility and customization when it comes to assigning objects, allowing for more precise control over the behavior of 
the assignment operation in C++ programs.

\begin{solution}[Overloading Assignment Operator Example]
    Below is an example of overloading the assignment operator in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>

    class Car {
    private:
        std::string brand;
    
    public:
        Car(const std::string& carBrand) : brand(carBrand) {}
    
        // Overloaded assignment operator
        Car& operator=(const Car& other) {
            if (this != &other) {
                brand = other.brand;
                std::cout << "Assignment operator called." << std::endl;
            }
            return *this;
        }
    
        void displayBrand() {
            std::cout << "Brand: " << brand << std::endl;
        }
    };
    
    int main() {
        Car car1("Toyota");
        Car car2("Honda");
    
        car1.displayBrand();  // Output: Brand: Toyota
        car2.displayBrand();  // Output: Brand: Honda
    
        car2 = car1;  // Overloaded assignment operator is invoked here
    
        car1.displayBrand();  // Output: Brand: Toyota
        car2.displayBrand();  // Output: Brand: Toyota
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline
    
    In this code, we have a `Car' class with a `brand' attribute and a constructor `Car(const std::string\& carBrand)' to initialize the `brand' attribute
    
    The key aspect is the overloaded assignment operator `Car\& operator=(const Car\& other)'. This assignment operator is defined within the `Car' class and provides a custom implementation for assigning one `Car' object to another. It first checks if the source object 
    (`other') is not the same as the target object (`this') to avoid self-assignment. Then, it assigns the `brand' value of the source object to the target object and outputs a message indicating that the assignment operator is called. The assignment operator returns a 
    reference to the modified object. In the `main()' function, we create two `Car' objects, `car1' and `car2', with different brand names. We call the `displayBrand()' function to verify their respective brand names. Next, we assign `car1' to `car2' using the overloaded 
    assignment operator. This invokes the assignment operator, which copies the `brand' value of `car1' to `car2'. After the assignment, we call the `displayBrand()' function again to confirm that `car2' now has the same brand as `car1'.
    
    The example demonstrates the overloading of the assignment operator in C++. By providing a custom implementation for the assignment operator, developers can define their own rules for copying or transferring data between objects of the same class. This allows for greater 
    control over the behavior of the assignment operation, ensuring that objects are assigned correctly and any necessary operations, such as deep copying, are performed. Overloading the assignment operator provides flexibility and customization in handling object assignments in C++ programs.
\end{solution}

\subsection*{Sec. 4.11 - Rule of Three}

The Rule of Three in object-oriented programming (OOP) states that if a class requires the explicit definition of a destructor, copy constructor, or copy assignment operator, then it most likely requires all three. This rule arises from the need to properly manage resources, 
particularly when a class contains dynamically allocated memory or other non-copyable resources. By implementing all three functions, developers ensure that objects are correctly initialized, copied, and deallocated. Failure to adhere to the Rule of Three can lead to issues such as memory leaks, 
resource leaks, or unexpected object state modifications. By following this rule, developers can ensure proper resource management and maintain the integrity and behavior of objects in OOP programs.

\begin{solution}[Rule of Three Example]
    Below is an example of the rule of three in C++:
    
    \horizontalline
    
    \begin{verbatim}   
    #include <iostream>
    #include <cstring>
    
    class String {
    private:
        char* data;
    
    public:
        String(const char* str) {
            size_t length = strlen(str);
            data = new char[length + 1];
            strcpy(data, str);
        }
    
        ~String() {
            delete[] data;
        }
    
        String(const String& other) {
            size_t length = strlen(other.data);
            data = new char[length + 1];
            strcpy(data, other.data);
        }
    
        String& operator=(const String& other) {
            if (this != &other) {
                delete[] data;
                size_t length = strlen(other.data);
                data = new char[length + 1];
                strcpy(data, other.data);
            }
            return *this;
        }
    
        void print() {
            std::cout << data << std::endl;
        }
    };
    
    int main() {
        String s1("Hello");
        String s2 = s1;  // Copy constructor is invoked
    
        s1.print();  // Output: Hello
        s2.print();  // Output: Hello
    
        String s3("World");
        s2 = s3;  // Copy assignment operator is invoked
    
        s2.print();  // Output: World
    
        return 0;
    }
        \end{verbatim}
    
    \horizontalline

    In this code, we have a `String' class that represents a string object. The class manages a dynamically allocated character array `data' to hold the string
    
    The example adheres to the Rule of Three by defining the destructor, copy constructor, and copy assignment operator. The destructor `\~String()' deallocates the dynamically allocated memory held by `data'. The copy constructor `String(const String\& other)' creates a new `String' object 
    by making a deep copy of the `data' from the source object. The copy assignment operator `String\& operator=(const String\& other)' assigns the `data' from the source object to the target object, handling the deallocation and reallocation of memory.
    
    In the `main()' function, we create `String' objects `s1', `s2', and `s3'. We initialize `s1' with the string "Hello" and then create `s2' as a copy of `s1' using the copy constructor. We print the contents of both `s1' and `s2' to verify that they have the same string value. Next, we 
    create `s3' with the string "World" and assign it to `s2' using the copy assignment operator. This invokes the copy assignment operator, which deallocates the `data' of `s2' and copies the `data' from `s3'. We print the contents of `s2' to confirm that it now holds the string "World".
    
    The example demonstrates the Rule of Three in action, where the destructor, copy constructor, and copy assignment operator are implemented to ensure proper resource management and object behavior. By following this rule, developers can prevent memory leaks, resource leaks, or unexpected 
    object state modifications caused by incorrect copying or destruction of objects. Adhering to the Rule of Three is crucial when dealing with classes that manage resources or have non-copyable members, ensuring the correct behavior and integrity of objects in C++ programs.
\end{solution}

\subsection{Chapter 5 - Lists}

The second chapter of this week is Chapter 5 - Lists.

\subsection*{Sec. 5.1 - List Abstract Data Type (ADT)}

The list abstract data type (ADT) represents a collection of elements where each element is linked to the next element in the sequence. It allows for efficient insertion, deletion, and retrieval operations. The list ADT supports dynamic resizing, allowing for the storage of an arbitrary number 
of elements. Lists can be implemented using various data structures, such as linked lists or arrays. They provide flexibility in terms of element manipulation and are commonly used in scenarios where the order and accessibility of elements are important. The list ADT provides a versatile and efficient 
way to manage collections of data in computer programs, facilitating operations that involve sequential access and modification of elements.

\begin{solution}[List (ADT) Example]
    Below is an example of a list (ADT) in C++: 

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* next;

        Node(int value) : data(value), next(nullptr) {}
    };

    class LinkedList {
    private:
        Node* head;
        Node* tail;

    public:
        LinkedList() : head(nullptr), tail(nullptr) {}

        void insert(int value) {
            Node* newNode = new Node(value);
            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else {
                tail->next = newNode;
                tail = newNode;
            }
        }

        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };

    int main() {
        LinkedList myList;

        myList.insert(5);
        myList.insert(10);
        myList.insert(15);

        myList.display();  // Output: 5 10 15

        return 0;
    }
    \end{verbatim}

    \horizontalline

    In this code, we have a Node class that represents a node in a linked list. Each node holds an integer value (data) and a pointer to the next node (next).

    The LinkedList class represents the list abstract data type. It consists of a head pointer (head) and a tail pointer (tail). The insert function inserts a new node with the given value at the end of the list. If the list 
    is empty, the new node becomes both the head and the tail. Otherwise, the new node is appended after the current tail, and the tail pointer is updated accordingly. The display function traverses the list, starting from 
    the head, and prints the data of each node. In the main() function, we create an instance of LinkedList named myList. We insert three elements into the list using the insert function, namely 5, 10, and 15. Finally, we call the display function to print the contents 
    of the list, which outputs "5 10 15".

    The example demonstrates the list abstract data type implemented using a linked list. It showcases the insertion operation, where elements are added to the end of the list, preserving the order. The linked list provides 
    efficient insertion and sequential access to elements. It allows for the dynamic storage of elements, as nodes are dynamically allocated during insertion. The list ADT offers flexibility and versatility in managing collections 
    of data, enabling efficient manipulation and traversal of elements.
\end{solution}

\subsection*{Sec. 5.2 - Singly-Linked Lists}

\subsubsection{Singly-Linked List Data Structure}

A singly-linked list is a data structure in which each element, known as a node, contains data and a pointer to the next node in the list. The list is "singly-linked" because it allows traversal in one direction, from the head (the first node) to the tail (the last node). 
Singly-linked lists are dynamic data structures, allowing for efficient insertion and deletion of elements at the beginning or end of the list. However, accessing or modifying elements in the middle of the list can be less efficient due to the need to traverse from the head. 
Singly-linked lists are commonly used when the order of elements matters, and frequent insertions and deletions are expected, but random access is not a primary requirement. They provide a flexible and memory-efficient way to manage and manipulate collections of data in various 
programming scenarios.

\subsubsection{Appending to Singly Linked List}

Appending to a singly-linked list involves adding a new element to the end of the list. To perform this operation, the tail pointer of the list is utilized. If the list is initially empty, the new element becomes both the head and the tail. Otherwise, the tail pointer is updated 
to point to the new element, effectively making it the new tail. This operation is efficient in a singly-linked list since inserting at the end does not require traversing the entire list. By appending elements to a singly-linked list, the list can dynamically grow, maintaining 
the order of elements while enabling efficient insertion of new elements at the tail.

\subsubsection{Prepending to Singly Linked List}

Prepending to a singly-linked list involves adding a new element at the beginning of the list. This operation requires updating the head pointer of the list to point to the new element, making it the new head. If the list is initially empty, the new element becomes both the head 
and the tail. Prepending is an efficient operation in a singly-linked list since it does not require traversing the entire list. By prepending elements to a singly-linked list, the list can dynamically grow while maintaining the order of elements, allowing for efficient insertion 
of new elements at the beginning. This operation is useful in scenarios where the most recent or frequently accessed elements need to be accessed quickly without traversing the entire list.

\begin{solution}[Singly Linked List Example]
    Below is an example of a singly linked list in C++:

    \horizontalline
    
    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* next;
    
        Node(int value) : data(value), next(nullptr) {}
    };
    
    class SinglyLinkedList {
    private:
        Node* head;
        Node* tail;
    
    public:
        SinglyLinkedList() : head(nullptr), tail(nullptr) {}
    
        void append(int value) {
            Node* newNode = new Node(value);
            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else {
                tail->next = newNode;
                tail = newNode;
            }
        }
    
        void prepend(int value) {
            Node* newNode = new Node(value);
            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else {
                newNode->next = head;
                head = newNode;
            }
        }
    
        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };
    
    int main() {
        SinglyLinkedList myList;
    
        myList.append(5);
        myList.append(10);
        myList.append(15);
    
        myList.display();  // Output: 5 10 15
    
        myList.prepend(2);
        myList.prepend(1);
    
        myList.display();  // Output: 1 2 5 10 15
    
        return 0;
    }
    \end{verbatim}

    \horizontalline

    The `SinglyLinkedList' class represents the singly-linked list data structure. It consists of a head pointer (`head') and a tail pointer (`tail'). The `append' function adds a new node with the given value at the end of the list. 
    If the list is empty, the new node becomes both the head and the tail. Otherwise, the new node is appended after the current tail, and the tail pointer is updated accordingly. The `prepend' function adds a new node with the given 
    value at the beginning of the list. If the list is empty, the new node becomes both the head and the tail. Otherwise, the new node is inserted before the current head, and the head pointer is updated. The `display' function traverses 
    the list and prints the data of each node.

    In the `main()' function, we create an instance of `SinglyLinkedList' named `myList'. We append three elements to the list using the `append' function, namely 5, 10, and 15. We then display the contents of the list, which outputs 
    "5 10 15". Next, we prepend two elements to the list using the `prepend' function, namely 2 and 1. Finally, we display the updated contents of the list, which outputs "1 2 5 10 15".

    The example demonstrates the concepts of appending and prepending to a singly-linked list. The `append' operation adds elements at the end, while the `prepend' operation adds elements at the beginning. These operations allow for dynamic 
    growth of the list while preserving the order of elements. By using the appropriate pointers, the list is efficiently updated without the need to traverse the entire list. Singly-linked lists provide flexibility in adding elements at 
    either end, allowing for efficient insertion of new elements in various programming scenarios.
\end{solution}

\subsection*{Sec. 5.3 - List Data Structure}

The list data structure is a fundamental abstract data type that represents a collection of elements. Lists provide a dynamic and flexible way to store and manage data, allowing for efficient insertion, deletion, and retrieval operations. 
The key characteristic of lists is that they maintain the order of elements as they are added or removed. This order can be based on the position of the elements (e.g., positional index) or on the values of the elements themselves.

Lists can be implemented using different underlying data structures, such as arrays or linked lists. Each implementation has its advantages and trade-offs. Arrays provide fast random access to elements but can be less efficient for insertions 
and deletions, especially in the middle of the list, as it requires shifting elements. Linked lists, on the other hand, offer efficient insertions and deletions but require sequential traversal for accessing elements. Linked lists also have 
the flexibility to grow dynamically by allocating memory for new elements as needed.

Lists support various operations to manipulate the elements, including appending, prepending, inserting, deleting, and searching. These operations allow for the modification and rearrangement of elements within the list. Lists can also support 
additional functionality such as sorting, merging, and splitting.

Lists are widely used in computer programming and software development, as they provide an essential building block for many other data structures and algorithms. They are particularly useful in scenarios where the order of elements matters and 
frequent insertions and deletions are expected. Lists are commonly employed in applications involving data processing, task scheduling, file systems, and more.

Overall, the list data structure offers a flexible and efficient way to organize and manage collections of elements, making it a fundamental tool in computer science and programming. It provides a foundation for implementing more complex data 
structures and algorithms, while also serving as a versatile and practical solution for various programming tasks.

\subsection*{Sec. 5.4 - Singly-Linked Lists: Insert}

Inserting in a singly-linked list involves adding a new element at a specific position within the list. This operation requires updating the appropriate pointers to maintain the integrity and order of the list. Insertion can be performed at the 
beginning, in the middle, or at the end of the list. To insert an element at the beginning, the head pointer is updated to point to the new node, while its next pointer is set to the current head. For inserting in the middle, the pointers of the 
adjacent nodes are modified to link the new node appropriately. Inserting at the end involves updating the tail pointer to point to the new node and setting its next pointer to nullptr. Inserting in a singly-linked list is efficient for operations 
that involve updating only a few pointers, allowing for dynamic growth and modification of the list while preserving the order of elements.

\begin{solution}[Singly-Linked List Insert Example]
    Below is an example of inserting into a singly-linked list in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* next;
    
        Node(int value) : data(value), next(nullptr) {}
    };
    
    class SinglyLinkedList {
    private:
        Node* head;
        Node* tail;
    
    public:
        SinglyLinkedList() : head(nullptr), tail(nullptr) {}
    
        void insert(int value, int position) {
            Node* newNode = new Node(value);
    
            if (head == nullptr || position == 0) {
                newNode->next = head;
                head = newNode;
                if (tail == nullptr) {
                    tail = newNode;
                }
            } else {
                Node* current = head;
                int count = 0;
    
                while (current->next != nullptr && count < position - 1) {
                    current = current->next;
                    count++;
                }
    
                newNode->next = current->next;
                current->next = newNode;
    
                if (newNode->next == nullptr) {
                    tail = newNode;
                }
            }
        }
    
        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };
    
    int main() {
        SinglyLinkedList myList;
    
        myList.insert(5, 0);   // Insert 5 at position 0
        myList.insert(10, 1);  // Insert 10 at position 1
        myList.insert(7, 1);   // Insert 7 at position 1
    
        myList.display();  // Output: 5 7 10
    
        return 0;
    }        
    \end{verbatim}

    \horizontalline

    The `SinglyLinkedList' class represents the singly-linked list data structure. It consists of a head pointer (`head') and a tail pointer (`tail'). The `insert' function adds a new node with the given value at the specified position within the 
    list. If the list is empty or the position is 0, the new node becomes the new head, and its next pointer is set to the previous head. If the position is not at the beginning, the function iterates through the list to find the appropriate position. 
    Once found, the new node is inserted by updating the pointers of the previous and next nodes accordingly. The `display' function traverses the list and prints the data of each node.

    In the `main()' function, we create an instance of `SinglyLinkedList' named `myList'. We insert three elements into the list using the `insert' function, with values 5, 10, and 7, respectively, at positions 0, 1, and 1. Finally, we call the `display' 
    function to print the contents of the list, which outputs "5 7 10".

    The example demonstrates the concept of inserting an element at a specific position in a singly-linked list. The `insert' operation allows for dynamic modification of the list by rearranging the pointers of the nodes. By updating the appropriate 
    pointers, the new node is seamlessly integrated into the list while maintaining the order of elements. Singly-linked lists provide an efficient way to insert elements at various positions, enabling flexibility and versatility in managing collections of data.
\end{solution}

\subsection*{Sec. 5.5 - Singly-Linked Lists: Remove}

Removing elements from a singly-linked list involves deleting a node at a specific position or with a particular value. To remove a node at a given position, the pointers of the preceding and following nodes are adjusted to bypass the node being removed, effectively 
removing it from the list. If the node to be removed is the head, the head pointer is updated to point to the next node. Removing a node based on a value requires traversing the list to find the node with the desired value. Once found, the pointers of the preceding 
and following nodes are adjusted to exclude the node with the target value. Removing elements from a singly-linked list is an efficient operation, especially when the position or value to be removed is known, as it involves updating a few pointers rather than shifting 
elements. This flexibility in removing nodes allows for dynamic modification of the list while maintaining the order of the remaining elements.

\begin{solution}[Singly-Linked List Remove Example]
    Below is an example of removing in a singly-linked list in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* next;
    
        Node(int value) : data(value), next(nullptr) {}
    };
    
    class SinglyLinkedList {
    private:
        Node* head;
        Node* tail;
    
    public:
        SinglyLinkedList() : head(nullptr), tail(nullptr) {}
    
        void remove(int position) {
            if (head == nullptr)
                return;
    
            Node* current = head;
    
            if (position == 0) {
                head = head->next;
                delete current;
    
                if (head == nullptr)
                    tail = nullptr;
            } else {
                Node* previous = nullptr;
                int count = 0;
    
                while (current != nullptr && count < position) {
                    previous = current;
                    current = current->next;
                    count++;
                }
    
                if (current != nullptr) {
                    previous->next = current->next;
    
                    if (previous->next == nullptr)
                        tail = previous;
    
                    delete current;
                }
            }
        }
    
        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };
    
    int main() {
        SinglyLinkedList myList;
    
        myList.remove(0);  // No effect, list is empty
    
        myList.display();  // Output: (empty)
    
        myList.insert(5, 0);   // Insert 5 at position 0
        myList.insert(10, 1);  // Insert 10 at position 1
        myList.insert(7, 1);   // Insert 7 at position 1
    
        myList.display();  // Output: 5 7 10
    
        myList.remove(1);  // Remove element at position 1
    
        myList.display();  // Output: 5 10
    
        return 0;
    }        
    \end{verbatim}

    \horizontalline

    The `SinglyLinkedList' class represents the singly-linked list data structure. It consists of a head pointer (`head') and a tail pointer (`tail'). The `remove' function removes a node at the specified position within the list. If the list is empty or the position 
    is out of range, the function does nothing. If the position is 0, the head is updated to the next node, and the original head is deleted. If the position is not 0, the function iterates through the list to find the node at the specified position. Once found, the 
    function updates the pointers of the previous and following nodes to exclude the node being removed and deletes the target node. The `display' function traverses the list and prints the data of each node.

    In the `main()' function, we create an instance of `SinglyLinkedList' named `myList'. We attempt to remove an element from an empty list, which has no effect. We then insert three elements into the list using the `insert' function, with values 5, 10, and 7, respectively, 
    at positions 0, 1, and 1. We display the contents of the list, which outputs "5 7 10". Next, we `remove' the element at position 1 using the remove function. Finally, we display the updated contents of the list, which outputs "5 10" since the element with value 7 has 
    been successfully removed.

    The example demonstrates the concept of removing elements from a singly-linked list. The `remove' operation allows for the dynamic modification of the list by adjusting the pointers of the preceding and following nodes. By updating these pointers, the target node is 
    effectively bypassed and removed from the list while preserving the order of the remaining elements. Removing nodes from a singly-linked list is an efficient operation, as it involves updating a few pointers rather than shifting elements. This flexibility in removing nodes 
    provides practicality and versatility in managing collections of data with varying needs.
\end{solution}

\subsection*{Sec. 5.6 - Linked List Search}

Linked list search involves finding a specific value or element within a linked list data structure. The search operation requires traversing through the list, examining each node's data until the desired value is found or the end of the list is reached. During the traversal, 
the data in each node is compared with the target value, and if a match is found, the search operation can be considered successful. Linked list search is a linear search process that has a time complexity of $\mathcal{O}(n)$ in the worst case, where $n$ is the number of elements in the list. 
The efficiency of the search operation can be improved by using techniques such as maintaining a sorted linked list or utilizing additional data structures like hash tables or binary search trees.

\begin{solution}[Linked List Search Example]
    Below is an example of a linked list search in C++:
    
    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* next;
    
        Node(int value) : data(value), next(nullptr) {}
    };
    
    class SinglyLinkedList {
    private:
        Node* head;
    
    public:
        SinglyLinkedList() : head(nullptr) {}
    
        bool search(int value) {
            Node* current = head;
    
            while (current != nullptr) {
                if (current->data == value) {
                    return true;  // Value found
                }
                current = current->next;
            }
    
            return false;  // Value not found
        }
    
        void insert(int value) {
            Node* newNode = new Node(value);
    
            if (head == nullptr) {
                head = newNode;
            } else {
                Node* current = head;
                while (current->next != nullptr) {
                    current = current->next;
                }
                current->next = newNode;
            }
        }
    };
    
    int main() {
        SinglyLinkedList myList;
    
        myList.insert(5);
        myList.insert(10);
        myList.insert(7);
    
        int searchValue = 10;
        if (myList.search(searchValue)) {
            std::cout << "Value " << searchValue << " found in the linked list." 
            << std::endl;
        } else {
            std::cout << "Value " << searchValue << " not found in the linked list." 
            << std::endl;
        }
    
        return 0;
    }
    \end{verbatim}

    \horizontalline

    The `SinglyLinkedList' class represents the singly-linked list data structure. It consists of a head pointer (`head'). The `search' function performs a search operation to find a specific value within the list. It starts from the head and traverses the list by comparing the value in each 
    node with the target value. If a match is found, the function returns `true', indicating that the value exists in the list. If the end of the list is reached without finding a match, the function returns `false', indicating that the value does not exist in the list. The `insert' function 
    adds new nodes to the end of the list.

    In the `main()' function, we create an instance of `SinglyLinkedList' named `myList'. We insert three elements with values 5, 10, and 7, respectively. We then perform a search for the value 10 using the `search' function. Since 10 is present in the list, the program outputs "Value 10 found 
    in the linked list." The example demonstrates how to search for a specific value within a linked list using a linear search approach. By traversing the list and comparing each element, the search operation efficiently determines the presence or absence of a target value in the linked list.
\end{solution}

\subsection*{Sec. 5.7 - Doubly-Linked Lists}

\subsubsection{Overview}

A doubly linked list is a type of linked list where each node contains two pointers: one pointing to the previous node and another pointing to the next node. This bidirectional linkage allows traversal in both directions, enabling efficient insertion, deletion, and searching operations. Each node 
in a doubly linked list stores data and maintains references to the previous and next nodes, except for the first node (head) that only has a next pointer, and the last node (tail) that only has a previous pointer. The ability to traverse in both directions makes doubly linked lists useful for 
scenarios that require backward traversal or frequent insertions and deletions at both ends of the list. However, the presence of additional pointers increases the memory overhead compared to singly linked lists.

\subsubsection{Appending to a Doubly-Linked List}

Appending to a doubly linked list involves adding a new node at the end of the list. To append a node, a new node is created with the desired data, and the necessary pointers are adjusted to establish the appropriate connections. If the list is empty, the new node becomes both the head and the tail 
of the list. Otherwise, the new node's previous pointer is set to the current tail, and the current tail's next pointer is updated to point to the new node. Finally, the tail pointer is updated to point to the newly appended node. By properly updating the pointers, the new node is seamlessly integrated 
into the existing doubly linked list structure, preserving the order of elements and enabling efficient access to both the head and tail of the list.

\subsubsection{Prepending to a Doubly-Linked List}

Prepending to a doubly linked list involves adding a new node at the beginning of the list. To prepend a node, a new node is created with the desired data, and the necessary pointers are adjusted to establish the appropriate connections. If the list is empty, the new node becomes both the head and the 
tail of the list. Otherwise, the new node's next pointer is set to the current head, and the current head's previous pointer is updated to point to the new node. Finally, the head pointer is updated to point to the newly prepended node. By properly updating the pointers, the new node is seamlessly integrated 
into the existing doubly linked list structure, maintaining the order of elements and allowing efficient access to both the head and tail of the list. Prepending to a doubly linked list is an efficient operation, as it involves adjusting a few pointers without the need to traverse the entire list.

\begin{solution}[Doubly-Linked List Example]
    Below is an example of doubly-linked lists in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* prev;
        Node* next;

        Node(int value) : data(value), prev(nullptr), next(nullptr) {}
    };

    class DoublyLinkedList {
    private:
        Node* head;
        Node* tail;

    public:
        DoublyLinkedList() : head(nullptr), tail(nullptr) {}

        void append(int value) {
            Node* newNode = new Node(value);

            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else {
                tail->next = newNode;
                newNode->prev = tail;
                tail = newNode;
            }
        }

        void prepend(int value) {
            Node* newNode = new Node(value);

            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else {
                newNode->next = head;
                head->prev = newNode;
                head = newNode;
            }
        }

        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };

    int main() {
        DoublyLinkedList myList;

        myList.append(5);
        myList.append(10);
        myList.append(7);

        myList.display();  // Output: 5 10 7

        myList.prepend(3);
        myList.prepend(1);

        myList.display();  // Output: 1 3 5 10 7

        return 0;
    }
    \end{verbatim}

    \horizontalline

    The `DoublyLinkedList' class represents the doubly linked list data structure. It consists of a head pointer (`head') and a tail pointer (`tail'). The `append' function appends a new node with the specified value at the end of the list. It creates a new node, adjusts the pointers of the current tail node and 
    the new node, and updates the tail pointer accordingly. The `prepend' function prepends a new node with the specified value at the beginning of the list. It creates a new node, adjusts the pointers of the current head node and the new node, and updates the head pointer accordingly. The `display' function traverses 
    the list and prints the data of each node.

    In the `main()' function, we create an instance of `DoublyLinkedList' named `myList'. We append three elements with values 5, 10, and 7, respectively, and display the contents of the list. The output is "5 10 7". Next, we prepend two elements with values 3 and 1, respectively, and display the updated contents of 
    the list. The output is "1 3 5 10 7", showing that the new nodes are correctly appended and prepended to the doubly linked list.

    The example demonstrates how to append and prepend nodes to a doubly linked list. By properly adjusting the pointers of the nodes and updating the head and tail pointers, the new nodes are seamlessly integrated into the existing list structure. Doubly linked lists provide efficient operations for adding elements at 
    both ends, allowing for flexibility in managing and manipulating the list's contents.
\end{solution}

\subsection*{Sec. 5.8 - Doubly-Linked Litsts: Insert}

Inserting in a doubly linked list involves adding a new node at a specific position within the list. The insertion operation requires adjusting the pointers of the neighboring nodes to maintain the correct order. The process begins by creating a new node with the desired data. Then, the next and previous pointers of the 
new node are modified to establish the connections with the neighboring nodes. By updating the pointers of the preceding and succeeding nodes accordingly, the new node is seamlessly integrated into the list structure. Inserting in a doubly linked list provides flexibility in modifying the list by allowing the addition of 
elements at arbitrary positions, making it suitable for scenarios that require dynamic data manipulation and efficient data insertion.

\begin{solution}[Doubly-Linked List Insert Example]
    Below is an example of inserting into doubly-linked lists in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* prev;
        Node* next;
    
        Node(int value) : data(value), prev(nullptr), next(nullptr) {}
    };
    
    class DoublyLinkedList {
    private:
        Node* head;
        Node* tail;
    
    public:
        DoublyLinkedList() : head(nullptr), tail(nullptr) {}
    
        void insert(int value, int position) {
            Node* newNode = new Node(value);
    
            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else if (position == 0) {
                newNode->next = head;
                head->prev = newNode;
                head = newNode;
            } else {
                Node* current = head;
                int count = 0;
    
                while (current != nullptr && count < position) {
                    current = current->next;
                    count++;
                }
    
                if (current == nullptr) {
                    tail->next = newNode;
                    newNode->prev = tail;
                    tail = newNode;
                } else {
                    newNode->prev = current->prev;
                    newNode->next = current;
                    current->prev->next = newNode;
                    current->prev = newNode;
                }
            }
        }
    
        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };
    
    int main() {
        DoublyLinkedList myList;
    
        myList.insert(5, 0);   // Inserting at position 0
        myList.insert(10, 1);  // Inserting at position 1
        myList.insert(7, 1);   // Inserting at position 1
    
        myList.display();  // Output: 5 7 10
    
        return 0;
    }        
    \end{verbatim}

    \horizontalline

    The `DoublyLinkedList' class represents the doubly linked list data structure. It consists of a head pointer (`head') and a tail pointer (`tail'). The `insert' function inserts a new node with the specified value at the given position within the list. It handles different cases: if the list is empty, the new node 
    becomes both the head and the tail; if the position is 0, the new node is prepended to the list; otherwise, the function traverses the list to find the desired position. If the position exceeds the length of the list, the new node is appended to the end. Otherwise, the new node is inserted at the specified position 
    by updating the pointers of the neighboring nodes accordingly. The `display' function is used to traverse the list and print its contents.

    In the `main()' function, we create an instance of `DoublyLinkedList' named `myList'. We insert three elements with values 5, 10, and 7, respectively, at different positions within the list. After inserting the nodes, we display the contents of the list, which outputs "5 7 10". The example demonstrates how to insert 
    a node at a specific position in a doubly linked list. By appropriately adjusting the pointers of the neighboring nodes, the new node is seamlessly integrated into the list structure while preserving the order of the elements. Inserting in a doubly linked list provides flexibility in managing the list's contents.
\end{solution}

\subsection*{Sec. 5.9 - Doubly-Linked Lists: Remove}

Removing nodes from a doubly linked list involves unlinking a node from the list while maintaining the integrity of the remaining nodes. The removal process requires updating the pointers of the neighboring nodes to bypass the node being removed. To remove a node, the previous node's next pointer is connected to the next node, 
and the next node's previous pointer is connected to the previous node. Additionally, if the node being removed is the head or tail of the list, the head or tail pointers are updated accordingly. By properly adjusting the pointers and deallocating the memory occupied by the removed node, the doubly linked list structure is 
maintained, and the list's integrity is preserved. Removing nodes from a doubly linked list allows for efficient deletion of elements at arbitrary positions, enabling dynamic data manipulation and effective memory management.

\begin{solution}[Doubly-Linked List Remove Example]
    Below is an example of removing in doubly-linked lists in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* prev;
        Node* next;
    
        Node(int value) : data(value), prev(nullptr), next(nullptr) {}
    };
    
    class DoublyLinkedList {
    private:
        Node* head;
        Node* tail;
    
    public:
        DoublyLinkedList() : head(nullptr), tail(nullptr) {}
    
        void append(int value) {
            Node* newNode = new Node(value);
    
            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else {
                tail->next = newNode;
                newNode->prev = tail;
                tail = newNode;
            }
        }
    
        void remove(int value) {
            Node* current = head;
    
            while (current != nullptr) {
                if (current->data == value) {
                    if (current == head) {
                        head = current->next;
                        if (head != nullptr) {
                            head->prev = nullptr;
                        }
                    } else if (current == tail) {
                        tail = current->prev;
                        if (tail != nullptr) {
                            tail->next = nullptr;
                        }
                    } else {
                        current->prev->next = current->next;
                        current->next->prev = current->prev;
                    }
    
                    delete current;
                    return;
                }
    
                current = current->next;
            }
        }
    
        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };
    
    int main() {
        DoublyLinkedList myList;
    
        myList.append(5);
        myList.append(10);
        myList.append(7);
    
        myList.display();  // Output: 5 10 7
    
        myList.remove(10);
    
        myList.display();  // Output: 5 7
    
        return 0;
    }        
    \end{verbatim}

    \horizontalline

    The `DoublyLinkedList' class represents the doubly linked list data structure. It consists of a head pointer (`head') and a tail pointer (`tail'). The `append' function is used to append a new node with the specified value at the end of the list. It handles the case where the list is empty and adjusts the pointers accordingly. 
    The `remove' function removes a node with the specified value from the list. It traverses the list and checks if the current node matches the target value. If a match is found, the appropriate pointers are adjusted to bypass the node being removed. If the node being removed is the head or tail, the head or tail pointers are 
    updated accordingly. Finally, the memory occupied by the removed node is deallocated. The `display' function is used to traverse the list and print its contents.

    In the `main()' function, we create an instance of `DoublyLinkedList' named `myList' and append three elements with values 5, 10, and 7, respectively. After appending the nodes, we display the contents of the list, which outputs "5 10 7". We then call the `remove' function to remove the node with value 10 from the list. After 
    the removal, we display the updated contents of the list, which outputs "5 7". The example demonstrates how to remove a node from a doubly linked list
\end{solution}

\subsection*{Sec. 5.10 - Linked List Traversal}

\subsubsection{Overview}

Linked list traversal refers to the process of visiting each node in a linked list in order to perform some operation or access the data stored in the nodes. The traversal typically starts from the head of the list and iterates through the nodes until the end of the list is reached. During traversal, the data in each node can be 
processed, displayed, or used for some computation. By following the next pointers of the nodes, the traversal can effectively access all the elements in the linked list. Linked list traversal is an essential operation for analyzing, modifying, or displaying the contents of a linked list, and it allows for efficient and sequential 
access to the elements stored in the list.

\subsubsection{Doubly-Linked List Traversal}

Linked list traversal in a doubly linked list is similar to traversal in a singly linked list but with the added capability of traversing in both forward and backward directions. Starting from the head or tail of the list, the traversal can move through the list by following either the next or prev pointers of each node. This bidirectional 
traversal allows for flexibility in accessing and processing the data in each node. The traversal can be performed to display the elements, perform computations, search for specific values, or modify the data within the nodes. By leveraging the prev and next pointers, linked list traversal in a doubly linked list enables efficient and convenient 
navigation through the list in both directions, making it a versatile tool for various operations on the list's elements.

\begin{solution}[Linked List Traversal Example]
    Below is an example of traversing in a linked list in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* prev;
        Node* next;
    
        Node(int value) : data(value), prev(nullptr), next(nullptr) {}
    };
    
    class DoublyLinkedList {
    private:
        Node* head;
        Node* tail;
    
    public:
        DoublyLinkedList() : head(nullptr), tail(nullptr) {}
    
        void append(int value) {
            Node* newNode = new Node(value);
    
            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else {
                tail->next = newNode;
                newNode->prev = tail;
                tail = newNode;
            }
        }
    
        void displayForward() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    
        void displayBackward() {
            Node* current = tail;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->prev;
            }
            std::cout << std::endl;
        }
    };
    
    int main() {
        DoublyLinkedList myList;
    
        myList.append(5);
        myList.append(10);
        myList.append(7);
    
        std::cout << "Forward traversal: ";
        myList.displayForward();  // Output: 5 10 7
    
        std::cout << "Backward traversal: ";
        myList.displayBackward();  // Output: 7 10 5
    
        return 0;
    }        
    \end{verbatim}

    \horizontalline

    The `DoublyLinkedList' class represents the doubly linked list data structure. It consists of a head pointer (`head') and a tail pointer (`tail'). The `append' function is used to append a new node with the specified value at the end of the list, adjusting the pointers accordingly.

    The `displayForward' function is responsible for traversing the list in the forward direction, starting from the head. It iterates through the list by following the next pointers of each node and prints the data stored in each node.

    The `displayBackward' function performs the traversal in the backward direction, starting from the tail. It iterates through the list by following the prev pointers of each node and prints the data stored in each node.

    In the `main()' function, we create an instance of `DoublyLinkedList' named `myList' and append three elements with values 5, 10, and 7, respectively. We then call the `displayForward' and `displayBackward' functions to traverse and print the contents of the list in both forward and backward directions. The output demonstrates 
    the successful traversal of the doubly linked list in both directions, displaying "5 10 7" and "7 10 5" respectively. This example highlights how the prev and next pointers in a doubly linked list facilitate bidirectional traversal, allowing for convenient access and processing of the elements stored in the list.
\end{solution}

\subsection*{Sec. 5.11 - Sorting Linked Lists}

\subsubsection{Sorting for Singly-Linked Lists}

Sorting a singly linked list involves rearranging its nodes in a specific order based on the values they hold. Sorting algorithms like merge sort, insertion sort, or bubble sort can be applied to achieve this task. Since a singly linked list only allows traversal in the forward direction, sorting the list can be slightly more challenging 
compared to a doubly linked list. The process typically involves rearranging the next pointers of the nodes while keeping track of the previous nodes and updating the head pointer as necessary. Sorting a singly linked list improves its organization and allows for more efficient searching and accessing of elements. It is an important operation 
to enhance the functionality and performance of a singly linked list data structure.

\subsubsection{Sorting for Doubly-Linked Lists}

Sorting a doubly linked list involves rearranging its nodes in a specific order based on the values they hold. There are various sorting algorithms that can be applied to accomplish this task, such as bubble sort, insertion sort, selection sort, merge sort, or quicksort. The sorting process typically involves comparing adjacent nodes 
and swapping their positions until the entire list is sorted. The bidirectional nature of the doubly linked list allows for efficient swapping of nodes by adjusting the prev and next pointers. Sorting a doubly linked list provides an organized arrangement of its elements, making it easier to search, access, or perform operations on 
the list in a structured manner. It is a fundamental operation that contributes to improving the efficiency and usability of the doubly linked list data structure.

\begin{solution}[Sorting a Linked List Example]
    Below is an example of sorting a linked list in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* next;
    
        Node(int value) : data(value), next(nullptr) {}
    };
    
    class SinglyLinkedList {
    private:
        Node* head;
    
    public:
        SinglyLinkedList() : head(nullptr) {}
    
        void insert(int value) {
            Node* newNode = new Node(value);
    
            if (head == nullptr) {
                head = newNode;
            } else {
                Node* current = head;
                while (current->next != nullptr) {
                    current = current->next;
                }
                current->next = newNode;
            }
        }
    
        void display() {
            Node* current = head;
            while (current != nullptr) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    
        Node* merge(Node* first, Node* second) {
            if (first == nullptr)
                return second;
            if (second == nullptr)
                return first;
    
            Node* result;
            if (first->data <= second->data) {
                result = first;
                result->next = merge(first->next, second);
            } else {
                result = second;
                result->next = merge(first, second->next);
            }
            return result;
        }
    
        void split(Node* source, Node** frontRef, Node** backRef) {
            if (source == nullptr || source->next == nullptr) {
                *frontRef = source;
                *backRef = nullptr;
                return;
            }
    
            Node* slow = source;
            Node* fast = source->next;
    
            while (fast != nullptr) {
                fast = fast->next;
                if (fast != nullptr) {
                    slow = slow->next;
                    fast = fast->next;
                }
            }
    
            *frontRef = source;
            *backRef = slow->next;
            slow->next = nullptr;
        }
    
        void mergeSort(Node** headRef) {
            Node* head = *headRef;
            Node* a;
            Node* b;
    
            if (head == nullptr || head->next == nullptr)
                return;
    
            split(head, &a, &b);
    
            mergeSort(&a);
            mergeSort(&b);
    
            *headRef = merge(a, b);
        }
    
        void sort() {
            mergeSort(&head);
        }
    };
    
    int main() {
        SinglyLinkedList myList;
    
        myList.insert(5);
        myList.insert(10);
        myList.insert(2);
        myList.insert(8);
        myList.insert(3);
    
        std::cout << "Before sorting: ";
        myList.display();  // Output: 5 10 2 8 3
    
        myList.sort();
    
        std::cout << "After sorting: ";
        myList.display();  // Output: 2 3 5 8 10
    
        return 0;
    }        
    \end{verbatim}

    \horizontalline

    The `SinglyLinkedList' class represents the singly linked list data structure. It consists of a head pointer (`head') that points to the first node in the list. The `insert' function is used to insert a new node with the specified value at the end of the list.

    The `display' function traverses the list from the head node to the last node and prints the data stored in each node. The `merge' function is a helper function that merges two sorted linked lists into a single sorted list. The `split' function divides the list into two halves, using the slow and fast pointer approach. The `mergeSort' 
    function recursively splits the list into smaller sublists, sorts them using merge sort, and then merges them back together. The `sort' function serves as an entry point for sorting the linked list. It calls the `mergeSort' function to perform the sorting operation.

    In the `main()' function, we create an instance of `SinglyLinkedList' named `myList' and insert five elements with values 5, 10, 2, 8, and 3, respectively. We then call the `display' function to print the contents of the list before sorting. Next, we call the `sort' function to sort the list using merge sort. Finally, we call the `display' 
    function again to print the sorted list. The output demonstrates the successful sorting of the singly linked list, displaying "2 3 5 8 10". This example showcases the implementation of the merge sort algorithm on a singly linked list, effectively arranging the elements in ascending order.
\end{solution}

\subsection*{Sec. 5.12 - Linked List Dummy Nodes}

\subsubsection{Overview}

Dummy nodes, also known as sentinel nodes, are special nodes added to the beginning or end of a linked list. These nodes do not hold any meaningful data but serve as placeholders or markers to simplify the operations performed on the list. Dummy nodes can be used to eliminate special cases and edge conditions when inserting or removing elements, 
especially at the beginning or end of the list. They provide a consistent structure for traversal and manipulation, ensuring that the list's head and tail pointers always point to valid nodes. By using dummy nodes, code complexity can be reduced, and operations on linked lists can be streamlined, making the implementation more efficient and easier 
to manage.

\subsubsection{Singly-Linked List Implemention}

In the context of singly linked lists, dummy nodes are often used to simplify certain operations, especially at the beginning or end of the list. A common approach is to add a dummy node at the beginning of the list, referred to as the "dummy head." This dummy node acts as a placeholder and allows consistent handling of the list's head pointer, even 
when inserting or removing elements. With a dummy head, the head pointer always points to a valid node, eliminating the need for special cases when manipulating the first element. Dummy nodes in singly linked lists enhance code readability and maintain consistency in operations, making it easier to handle edge cases and simplifying the implementation 
of algorithms and data structures that rely on singly linked lists.

\subsubsection{Doubly-Linked List Implementation}

In the context of doubly linked lists, dummy nodes are commonly used to simplify operations at both the beginning and end of the list. Similar to singly linked lists, a dummy node can be added at the beginning of the list, called the "dummy head," and another dummy node at the end, known as the "dummy tail." These dummy nodes serve as placeholders and 
allow for consistent handling of both the head and tail pointers, ensuring that they always point to valid nodes. By using dummy nodes, the implementation of operations such as inserting or removing elements at the beginning or end becomes more streamlined, as special cases and edge conditions are eliminated. Dummy nodes in doubly linked lists provide 
a standardized structure for traversal and manipulation, enhancing code clarity and reducing complexity. They make it easier to handle boundary cases and simplify the implementation of algorithms and data structures that rely on doubly linked lists.

\begin{solution}[Dummy Nodes Example]
    Below is an example of dummy nodes in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* prev;
        Node* next;
    
        Node(int value) : data(value), prev(nullptr), next(nullptr) {}
    };
    
    class DoublyLinkedList {
    private:
        Node* dummyHead;
        Node* dummyTail;
    
    public:
        DoublyLinkedList() {
            dummyHead = new Node(-1);  // Dummy head with data -1
            dummyTail = new Node(-1);  // Dummy tail with data -1
    
            dummyHead->next = dummyTail;
            dummyTail->prev = dummyHead;
        }
    
        void insert(int value) {
            Node* newNode = new Node(value);
    
            newNode->next = dummyTail;
            newNode->prev = dummyTail->prev;
            dummyTail->prev->next = newNode;
            dummyTail->prev = newNode;
        }
    
        void display() {
            Node* current = dummyHead->next;
            while (current != dummyTail) {
                std::cout << current->data << " ";
                current = current->next;
            }
            std::cout << std::endl;
        }
    };
    
    int main() {
        DoublyLinkedList myList;
    
        myList.insert(5);
        myList.insert(10);
        myList.insert(2);
        myList.insert(8);
        myList.insert(3);
    
        std::cout << "Doubly linked list: ";
        myList.display();  // Output: 5 10 2 8 3
    
        return 0;
    }        
    \end{verbatim}

    \horizontalline

    The `DoublyLinkedList' class represents the doubly linked list data structure. It has two dummy nodes: `dummyHead' and `dummyTail'. These dummy nodes act as placeholders and ensure that the head and tail pointers always point to valid nodes. The `dummyHead' is initially connected to the `dummyTail' to indicate an empty list.

    The `insert' function inserts a new node with the specified value at the end of the list. It creates a new node, adjusts the pointers of the previous and next nodes accordingly, and connects the new node in between. The `display' function traverses the list starting from the dummy head and prints the data stored in each node until it reaches the dummy 
    tail, excluding the dummy nodes.

    In the `main()' function, we create an instance of `DoublyLinkedList' named `myList' and insert five elements with values 5, 10, 2, 8, and 3, respectively. We then call the `display' function to print the contents of the doubly linked list. The output demonstrates the successful insertion and display of the elements, showcasing the use of dummy nodes 
    in a doubly linked list.
\end{solution}

\subsection*{Sec. 5.13 - Linked Lists: Recursion}

\subsubsection{Forward Traversal}

Forward traversal in recursion of linked lists refers to the process of traversing a linked list recursively in the forward direction, starting from the head node and visiting each node until reaching the end of the list. In this approach, a recursive function is called on each node, which performs some operation or accesses the data of the current node before 
recursively calling itself on the next node. This continues until the end of the list is reached, typically indicated by a base case that terminates the recursion. Forward traversal in recursion provides a concise and elegant way to iterate over linked lists, simplifying the code and reducing the need for explicit loop structures. It allows for efficient processing 
of each node in a linked list and enables various operations, such as printing, searching, or modifying the list, to be implemented recursively.

\subsubsection{Reverse Traversal}

Reverse traversal in recursion of linked lists involves traversing a linked list in the reverse direction using a recursive approach. Instead of starting from the head node and moving towards the tail, as in forward traversal, reverse traversal begins from the tail node and moves towards the head. This is achieved by recursively calling the reverse traversal function 
on the next node before performing any operation or accessing the data of the current node. The recursion continues until the head node is reached, which acts as the base case to terminate the traversal. Reverse traversal in recursion allows for efficient processing of nodes in reverse order, enabling operations such as printing in reverse, reversing the list itself, 
or performing any other operations that require accessing nodes in the opposite direction. It offers a concise and elegant solution to handle reverse traversal scenarios, leveraging the power of recursion in linked list manipulation.

\subsubsection{Searching}

Searching in linked lists using recursion involves recursively traversing the list to find a specific element or perform a search operation. The recursive search function is typically called on each node, comparing the node's data with the target element. If a match is found, the search terminates, and the appropriate result or node reference is returned. If the current 
node does not match the target element, the recursion continues by calling the search function on the next node until either a match is found or the end of the list is reached, typically indicated by a base case. Recursive searching in linked lists provides a concise and elegant solution, leveraging the power of recursion to handle search operations efficiently. It allows 
for flexibility in implementing different search criteria and can be easily extended to handle various search algorithms, such as linear search or binary search in sorted lists, by appropriately adjusting the recursion logic and base case conditions.

\begin{solution}[Linked List Recursion Example]
    Below is an example of recursion in linked lists in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    class Node {
    public:
        int data;
        Node* next;
    
        Node(int value) : data(value), next(nullptr) {}
    };
    
    class LinkedList {
    private:
        Node* head;
    
    public:
        LinkedList() : head(nullptr) {}
    
        void insert(int value) {
            Node* newNode = new Node(value);
    
            if (head == nullptr) {
                head = newNode;
            } else {
                Node* current = head;
                while (current->next != nullptr) {
                    current = current->next;
                }
                current->next = newNode;
            }
        }
    
        bool searchRecursive(Node* node, int target) {
            if (node == nullptr) {
                return false;  // Base case: end of list reached, element not found
            }
    
            if (node->data == target) {
                return true;  // Base case: element found
            }
    
            return searchRecursive(node->next, target);  // Recursive call on next
        }
    
        bool search(int target) {
            return searchRecursive(head, target);
        }
    };
    
    int main() {
        LinkedList myList;
        myList.insert(5);
        myList.insert(10);
        myList.insert(2);
        myList.insert(8);
        myList.insert(3);
    
        int target = 10;
        bool found = myList.search(target);
        if (found) {
            std::cout << "Element " << target << " found in the linked list." << std::endl;
        } else {
            std::cout << "Element " << target << " not found in the linked list." << std::endl;
        }
    
        return 0;
    }
    \end{verbatim}

    \horizontalline

    The `searchRecursive' function takes two parameters: the current node and the target element to search for. It follows a recursive approach to traverse the list and compare the data of each node with the target. If the target is found, it returns `true', and if the end of the list is reached without finding the target, it returns `false'.

    The `search' function acts as a wrapper that initiates the search operation by calling `searchRecursive' on the `head' node. In the `main()' function, we create an instance of `LinkedList' named `myList' and insert several elements. We then perform a search for the target element, which is set to 10 in this example. The result is printed based on whether the 
    element is found or not.

    The example demonstrates how recursion can be used to search for an element in a linked list efficiently. It allows for a concise and elegant solution, leveraging the recursive nature of the problem and simplifying the search operation.
\end{solution}

\subsection*{Sec. 5.14 - Circular Lists}

A circular linked list is a type of linked list where the last node of the list points back to the first node, forming a circular structure. Unlike a traditional linked list where the last node points to null, a circular linked list provides a seamless loop through its nodes. This allows for continuous traversal of the list starting from any node, 
as each node has a reference to the next node, and the last node points back to the first node. Circular linked lists can be useful in scenarios where cyclic behavior or circular access is required, such as round-robin scheduling algorithms or implementing circular buffers. They offer efficient operations for insertion and deletion at the beginning 
or end of the list and enable convenient looping or rotation through the list elements.

\subsection*{Sec. 5.15 - Array-Based Lists}

An array-based list, also known as a dynamic array or resizable array, is a data structure that stores elements in a contiguous block of memory. It simulates the behavior of a list or array by dynamically allocating memory and resizing as needed. The elements are stored in a fixed-size array, and when the capacity of the array is reached, a new larger 
array is created and the elements are copied to the new array. This allows for efficient random access to elements and provides constant-time complexity for accessing elements by index. Array-based lists offer flexibility in adding and removing elements at the end of the list, and they provide a more memory-efficient alternative to linked lists in many 
scenarios. However, they may require occasional resizing operations, which can be costly in terms of time and memory.

\subsection*{Sec. 5.16 - Stack Abstract Data Type (ADT)}

The stack abstract data type (ADT) is a collection of elements that follows the Last-In-First-Out (LIFO) principle. It models a real-life stack, where elements are added and removed from the top of the stack. The key operations of a stack include push (adding an element to the top of the stack) and pop (removing the top element from the stack). Additionally, 
a stack typically provides a peek operation to access the top element without removing it and a isEmpty operation to check if the stack is empty. Stacks are widely used in various applications, such as function call stacks, expression evaluation, and backtracking algorithms. They provide efficient access to the most recently added elements and support a compact 
and intuitive way to manage data in a last-in-first-out fashion.

\subsection*{Sec. 5.17 - Stacks Using Linked Lists}

Stacks implemented using linked lists are a common way to represent the stack abstract data type (ADT). In this implementation, a linked list is used to store the elements of the stack, with each node representing an element. The top of the stack is represented by the head node of the linked list. When an element is pushed onto the stack, a new node is created 
and inserted at the beginning of the linked list, becoming the new head node. Similarly, when an element is popped from the stack, the head node is removed, and the next node becomes the new head node. This implementation allows for dynamic memory allocation and efficient push and pop operations, as they can be performed in constant time. Linked list-based stacks 
provide flexibility in terms of the size of the stack and can handle a variable number of elements. They are particularly useful in scenarios where the stack size is unpredictable or may change dynamically during runtime.

\subsection*{Sec. 5.18 - Array-Based Stacks}

Array-based stacks are a common implementation of the stack abstract data type (ADT) using arrays. In this implementation, an array is used to store the elements of the stack, with a variable indicating the top index of the stack. Elements are pushed onto the stack by incrementing the top index and inserting the element at that position in the array. Similarly, 
elements are popped from the stack by accessing the element at the top index and decrementing the top index. Array-based stacks provide efficient constant-time complexity for push and pop operations, as accessing elements by index in an array is a constant-time operation. However, they have a fixed capacity determined by the size of the underlying array, and resizing 
the array can be costly. Array-based stacks are well-suited for scenarios where the maximum number of elements in the stack is known or can be easily determined in advance, providing a more memory-efficient option compared to linked list-based implementations.

\begin{solution}[Array-Based Stack Example]
    Below is an example of an array-based stack in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>

    const int MAX_SIZE = 5;
    
    class Stack {
    private:
        int top;
        int arr[MAX_SIZE];
    
    public:
        Stack() : top(-1) {}
    
        bool isEmpty() {
            return (top == -1);
        }
    
        bool isFull() {
            return (top == MAX_SIZE - 1);
        }
    
        void push(int value) {
            if (isFull()) {
                std::cout << "Stack is full. Cannot push element." << std::endl;
                return;
            }
            top++;
            arr[top] = value;
        }
    
        int pop() {
            if (isEmpty()) {
                std::cout << "Stack is empty. Cannot pop element." << std::endl;
                return -1;
            }
            int popped = arr[top];
            top--;
            return popped;
        }
    
        int peek() {
            if (isEmpty()) {
                std::cout << "Stack is empty. Cannot peek element." << std::endl;
                return -1;
            }
            return arr[top];
        }
    };
    
    int main() {
        Stack myStack;
        myStack.push(5);
        myStack.push(10);
        myStack.push(7);
    
        std::cout << "Peek: " << myStack.peek() << std::endl;  // Outputs: 7
    
        int popped = myStack.pop();
        std::cout << "Popped: " << popped << std::endl;  // Outputs: 7
    
        myStack.push(3);
    
        std::cout << "Peek: " << myStack.peek() << std::endl;  // Outputs: 3
    
        return 0;
    }
    \end{verbatim}

    \horizontalline

    In the `push' function, a value is added to the stack by incrementing `top' and assigning the value to the corresponding index in the array. The `pop' function removes the top element by returning its value and decrementing `top'. The `peek' function returns the value of the top element without removing it.

    In the `main' function, we create an instance of the `Stack' class named `myStack' and perform stack operations. We push three elements onto the stack, then use the `peek' function to retrieve the top element (7) without removing it. We then pop an element from the stack (7), and push another element (3). Finally, we use `peek' again to retrieve the new top element (3).

    The example demonstrates how an array-based stack can be implemented in C++. The array acts as a container to store the elements of the stack, and the top index keeps track of the current position of the stack. Array-based stacks provide a simple and efficient way to manage elements using arrays, with constant-time complexity for push, pop, and peek operations.
\end{solution}

\subsection*{Sec. 5.19 - Queue Abstract Data Type (ADT)}

The queue abstract data type (ADT) represents a collection of elements that follows the First-In-First-Out (FIFO) principle. It models a real-life queue, where elements are inserted at the back and removed from the front. The main operations of a queue include enqueue (adding an element to the back of the queue) and dequeue (removing the front element from the queue). Additionally, 
a queue typically provides a peek operation to access the front element without removing it and an isEmpty operation to check if the queue is empty. Queues are commonly used in scenarios where the order of elements matters, such as task scheduling, event handling, and breadth-first search algorithms. They offer efficient insertion and removal of elements at the ends and provide a 
natural way to manage data in a first-in-first-out fashion.

\subsection*{Sec. 5.20 - Queues Using Linked Lists}

Queues implemented using linked lists are a common way to represent the queue abstract data type (ADT). In this implementation, a linked list is used to store the elements of the queue, with each node representing an element. The front of the queue is represented by the head node of the linked list, and the back of the queue is represented by the tail node. When an element is enqueued, 
a new node is created and inserted at the end of the linked list, becoming the new tail node. Similarly, when an element is dequeued, the head node is removed, and the next node becomes the new head node. This implementation allows for efficient insertion and removal of elements at both ends of the queue, as well as constant-time complexity for enqueue and dequeue operations. Linked list-based 
queues provide flexibility in terms of the size of the queue and can handle a variable number of elements. They are particularly useful in scenarios where the size of the queue may change dynamically and where efficient insertion and removal of elements are required.

\subsection*{Sec. 5.21 - Array-Based Queues}

\subsubsection{Overview}

Array-based queues are a common implementation of the queue abstract data type (ADT) using arrays. In this implementation, an array is used to store the elements of the queue, with two indices representing the front and back of the queue. Elements are enqueued at the back of the queue by incrementing the back index and inserting the element at that position in the array. Similarly, elements are 
dequeued from the front of the queue by accessing the element at the front index and incrementing the front index. Array-based queues provide efficient constant-time complexity for enqueue and dequeue operations, as accessing elements by index in an array is a constant-time operation. However, they have a fixed capacity determined by the size of the underlying array, and resizing the array can 
be costly. Array-based queues are well-suited for scenarios where the maximum number of elements in the queue is known or can be easily determined in advance, providing a more memory-efficient option compared to linked list-based implementations. They are commonly used in applications that require a simple and efficient queue structure with a fixed capacity.

\subsubsection{Bounded vs. Unbounded Queue}

Bounded and unbounded queues refer to two different types of queues based on their capacity and behavior. A bounded queue has a fixed capacity, meaning it can only hold a limited number of elements. Once the queue is full, any attempt to enqueue additional elements will result in an overflow condition. On the other hand, an unbounded queue has no fixed capacity and can dynamically grow to accommodate 
any number of elements. Enqueuing elements to an unbounded queue is always possible, as it can allocate additional memory to store new elements. However, this dynamic resizing can be resource-intensive and may result in memory allocation failures in extreme cases. The choice between bounded and unbounded queues depends on the specific requirements of an application. Bounded queues are suitable when 
the maximum number of elements is known and memory usage needs to be controlled. Unbounded queues, on the other hand, are preferable when the number of elements can vary greatly or when memory constraints are not a concern.

\subsubsection{Enqueue and Dequeue Operations}

The enqueue and dequeue operations are fundamental operations in a queue data structure. Enqueue refers to the process of adding an element to the back (or rear) of the queue, while dequeue refers to removing an element from the front (or head) of the queue. When enqueueing, the new element is inserted after the last element of the queue, and the rear pointer is updated accordingly. Dequeueing involves 
removing the element at the front of the queue and updating the front pointer to point to the next element. These operations follow the First-In-First-Out (FIFO) principle, ensuring that the element added first will be the first one to be removed. Enqueue and dequeue operations are typically performed in constant time complexity, making queues an efficient choice for managing elements in a FIFO manner.

\begin{solution}[Array-Based Queue Example]
    Below is an example of an array-based queue example in C++:

    \horizontalline

    \begin{verbatim}
    #include <iostream>
    #define MAX_SIZE 5
    
    class ArrayQueue {
    private:
        int front, rear;
        int queue[MAX_SIZE];
    
    public:
        ArrayQueue() {
            front = -1;
            rear = -1;
        }
    
        bool isEmpty() {
            return (front == -1 && rear == -1);
        }
    
        bool isFull() {
            return (rear == MAX_SIZE - 1);
        }
    
        void enqueue(int item) {
            if (isFull()) {
                std::cout << "Queue is full. Cannot enqueue element." << std::endl;
                return;
            }
            if (isEmpty()) {
                front = 0;
            }
            rear++;
            queue[rear] = item;
            std::cout << item << " enqueued successfully." << std::endl;
        }
    
        void dequeue() {
            if (isEmpty()) {
                std::cout << "Queue is empty. Cannot dequeue element." << std::endl;
                return;
            }
            std::cout << queue[front] << " dequeued successfully." << std::endl;
            if (front == rear) {
                front = -1;
                rear = -1;
            } else {
                front++;
            }
        }
    
        void display() {
            if (isEmpty()) {
                std::cout << "Queue is empty." << std::endl;
                return;
            }
            std::cout << "Queue elements: ";
            for (int i = front; i <= rear; i++) {
                std::cout << queue[i] << " ";
            }
            std::cout << std::endl;
        }
    };
    
    int main() {
        ArrayQueue queue;
        queue.enqueue(10);
        queue.enqueue(20);
        queue.enqueue(30);
        queue.display();  // Output: Queue elements: 10 20 30
        queue.dequeue();
        queue.display();  // Output: Queue elements: 20 30
        queue.enqueue(40);
        queue.enqueue(50);
        queue.enqueue(60);  // Output: Queue is full. Cannot enqueue element.
        return 0;
    }
    \end{verbatim}

    \horizontalline

    The example demonstrates an array-based queue implementation in C++. The `ArrayQueue' class maintains a fixed-size array to store the elements of the queue. It provides methods to check if the queue is empty or full, enqueue an element at the rear, dequeue an element from the front, and display the queue elements. The operations are performed in constant time complexity, ensuring efficient handling 
    of elements based on the FIFO principle. The example demonstrates enqueueing and dequeueing elements, as well as handling cases when the queue is full or empty.
\end{solution}

\subsection*{Sec. 5.22 - Deque Abstract Data Type (ADT)}

The deque (double-ended queue) abstract data type (ADT) is a versatile data structure that allows insertion and deletion of elements at both ends. It combines the functionalities of stacks and queues, offering efficient insertion and removal operations at the front and back of the deque. Elements can be added or removed from either end, enabling flexibility in various applications. The deque ADT provides 
methods such as `push\_front()', `push\_back()', `pop\_front()', `pop\_back()', and `size()', among others, to manipulate and retrieve elements. Deques can be implemented using arrays or linked lists, with array-based implementations providing constant-time complexity for most operations and linked list implementations providing flexibility in terms of dynamic resizing. The deque ADT is widely used when elements 
need to be efficiently added or removed from either end, offering a powerful and adaptable data structure for various programming scenarios.