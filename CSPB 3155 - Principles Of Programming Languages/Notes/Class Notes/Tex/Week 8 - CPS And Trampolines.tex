\clearpage

\renewcommand{\ChapTitle}{CPS And Trampolines}
\renewcommand{\SectionTitle}{CPS And Trampolines}

\chapter{\ChapTitle}

\section{\SectionTitle}
\horizontalline{0}{0}

\subsection{Assigned Reading}

The reading for this week is from, \AtomicScalaBook, \EssOfPPLBook, \FuncOfPPLBook, and \ProgInScalaBook:

\begin{itemize}
    \item \textbf{N/A}
\end{itemize}

\subsection{Lectures}

The lectures for this week are:

\begin{itemize}
    \item \lecture{https://www.youtube.com/watch?v=Lg7dabPdOTs}{Intro To Continuation Passing Style}{14}
    \item \lecture{https://www.youtube.com/watch?v=xZPL4Ep9zvM}{Continuation Passing Style Examples}{30}
    \item \lecture{https://www.youtube.com/watch?v=8p-s8RxXKJE}{Continuation Passing Style Limitations}{8}
    \item \lecture{https://www.youtube.com/watch?v=SfaGIQ6KZ5Y}{Continuation Passing Style In Scala}{19}
    \item \lecture{https://www.youtube.com/watch?v=3P5XK5ktJUw}{Trampolines And Thunks}{6}
    \item \lecture{https://www.youtube.com/watch?v=MFSVY5rkVEU}{Trampolines In Scala}{15}
    \item \lecture{https://www.youtube.com/watch?v=G_nkWCJXyqc}{Recitation Video: Continuations In Scala}{36}
    \item \lecture{https://www.youtube.com/watch?v=kr1sD65kABM}{Recitation Video: Generics In Scala}{29}
\end{itemize}

\noindent The lecture notes for this week are:

\begin{itemize}
    \item Jupyter Notebooks
    \begin{itemize}
        \item \textbf{CSP And Trampolines - Continuation Passing Style Lecture Notes}
        \item \textbf{CSP And Trampolines - Generics Lecture Notes}
        \item \textbf{CSP And Trampolines - Trampolines Lecture Notes I}
        \item \textbf{CSP And Trampolines - Trampolines Lecture Notes II}
        \item \textbf{CSP And Trampolines Continuations Recitation}
        \item \textbf{CSP And Trampolines Continuations Recitation Solutions}
    \end{itemize}
\end{itemize}

\subsection{Assignments}

The assignment(s) for this week are:

\begin{itemize}
    \item \href{https://github.com/QuantumCompiler/CU/tree/main/CSPB%203155%20-%20Principles%20Of%20Programming%20Languages/Assignments/Problem%20Sets/Problem%20Set%207%20-%20CPS%20And%20Trampolines}{Problem Set 7 - CPS And Trampolines}
\end{itemize}

\subsection{Quiz}

The quiz for this week is:

\begin{itemize}
    \item \pdflink{\QuizDir Quiz 7 - CPS And Trampolines.pdf}{Quiz 7 - CPS And Trampolines}
\end{itemize}

\newpage

\subsection{Chapter Summary}

The first topic that is being covered this week is \textbf{Intro To Continuation Passing Style}.

\begin{notes}{Intro To Continuation Passing Style}
    \subsection*{Overview}

    Continuation Passing Style (CPS) is a style of programming where control is passed explicitly in the form of continuations. This technique allows for greater control over the flow of execution, 
    enabling advanced features like non-blocking I/O, backtracking, and concurrency.
    
    \subsubsection*{What is Continuation Passing Style?}
    
    CPS is a style of programming in which functions take an extra argument: a continuation. A continuation represents the rest of the computation that follows the function call.
    
    \begin{highlight}[What is Continuation Passing Style?]
    
        This example demonstrates the basic idea of CPS.
    
    \begin{code}[Scala]
    // CPS example
    def add(x: Int, y: Int, cont: Int => Int): Int = cont(x + y)
    
    val result = add(3, 4, x => x * 2)
    \end{code}
    
        In this example, "add" takes an additional argument "cont", a continuation function that specifies what to do with the result of "x + y". The continuation multiplies the result by 2.
    
        \begin{itemize}
            \item Functions take an additional argument: a continuation.
            \item The continuation represents the rest of the computation.
            \item Allows explicit control over the flow of execution.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Why Use CPS?}
    
    CPS provides several benefits, such as improved control over the execution order, enabling advanced features like non-blocking I/O and simplifying the implementation of certain algorithms.
    
    \begin{highlight}[Why Use CPS?]
    
        CPS is beneficial because it:
    
        \begin{itemize}
            \item \textbf{Improves Control}: Provides explicit control over the execution flow.
            \item \textbf{Enables Non-Blocking I/O}: Facilitates asynchronous programming.
            \item \textbf{Simplifies Backtracking}: Makes implementing backtracking algorithms more straightforward.
            \item \textbf{Supports Concurrency}: Allows for better handling of concurrent operations.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Converting to CPS}
    
    Converting a direct style function to CPS involves adding a continuation parameter and modifying the function to pass its result to the continuation instead of returning it.
    
    \begin{highlight}[Converting to CPS]
    
        This example shows how to convert a direct style function to CPS.
    
    \begin{code}[Scala]
    // Direct style
    def add(x: Int, y: Int): Int = x + y
    
    // CPS style
    def addCPS(x: Int, y: Int, cont: Int => Int): Int = cont(x + y)
    
    // Using CPS function
    val result = addCPS(3, 4, x => x * 2)
    \end{code}
    
        In this example, the direct style function "add" is converted to "addCPS" by adding a continuation parameter "cont". The function calls "cont" with the result of "x + y" instead of returning it.
    
        \begin{itemize}
            \item Add a continuation parameter to the function.
            \item Modify the function to pass the result to the continuation.
            \item Enables chaining of computations through continuations.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Using CPS for Advanced Control Flow}
    
    CPS can be used to implement advanced control flow mechanisms such as exception handling, coroutines, and backtracking.
    
    \begin{highlight}[Using CPS for Advanced Control Flow]
    
        This example demonstrates using CPS for error handling.
    
    \begin{code}[Scala]
    // CPS with error handling
    def safeDivide(x: Int, y: Int, cont: Int => Int, err: String => Int): Int =
        if (y == 0) err("Division by zero") else cont(x / y)
    
    val result = safeDivide(10, 0, r => r * 2, e => { println(e); 0 })
    \end{code}
    
        In this example, "safeDivide" uses CPS to handle division by zero errors. It takes an additional error continuation "err" to handle the error case.
    
        \begin{itemize}
            \item CPS allows implementation of advanced control flow mechanisms.
            \item Facilitates error handling by passing error continuations.
            \item Supports complex control structures like coroutines and backtracking.
        \end{itemize}
    
    \end{highlight}
    
    \begin{highlight}[Summary of Key Concepts]
    
        Continuation Passing Style (CPS) provides explicit control over the flow of execution in a program. Here are the key concepts covered in this section:
    
        \begin{itemize}
            \item \textbf{What is CPS?}: A style of programming where functions take an extra argument, a continuation, representing the rest of the computation.
            \item \textbf{Why Use CPS?}: Provides improved control, enables non-blocking I/O, simplifies backtracking, and supports concurrency.
            \item \textbf{Converting to CPS}: Involves adding a continuation parameter and passing the result to the continuation.
            \item \textbf{Using CPS for Advanced Control Flow}: Enables implementation of advanced control flow mechanisms such as error handling, coroutines, and backtracking.
        \end{itemize}
    
        These concepts illustrate the power and flexibility of CPS in managing control flow and enabling advanced programming techniques.
    
    \end{highlight}
\end{notes}

The next topic that is being covered this week is \textbf{Continuation Passing Style Examples}.

\begin{notes}{Continuation Passing Style Examples}
    \subsection*{Overview}

    Continuation Passing Style (CPS) provides a powerful way to manage control flow in programs. This section presents examples that illustrate the use of CPS for various programming tasks, 
    demonstrating its flexibility and power.
    
    \subsubsection*{Basic Arithmetic in CPS}
    
    A basic example of using CPS involves performing arithmetic operations. This example demonstrates adding two numbers using CPS.
    
    \begin{highlight}[Basic Arithmetic in CPS]
    
        This example shows how to perform addition using CPS.
    
    \begin{code}[Scala]
    // Addition in CPS
    def addCPS(x: Int, y: Int, cont: Int => Int): Int = cont(x + y)
    
    val result = addCPS(3, 4, sum => sum * 2)  // result = 14
    \end{code}
    
        In this example, the "addCPS" function takes two integers "x" and "y", and a continuation "cont". The result of "x + y" is passed to the continuation, which multiplies it by 2.
    
        \begin{itemize}
            \item Demonstrates basic arithmetic in CPS.
            \item The continuation processes the result of the addition.
            \item Shows how to chain computations.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Factorial in CPS}
    
    Calculating the factorial of a number using CPS illustrates how recursion can be handled in this style.
    
    \begin{highlight}[Factorial in CPS]
    
        This example demonstrates how to compute the factorial of a number using CPS.
    
    \begin{code}[Scala]
    // Factorial in CPS
    def factorialCPS(n: Int, cont: Int => Int): Int =
        if (n == 0) cont(1)
        else factorialCPS(n - 1, result => cont(n * result))
    
    val result = factorialCPS(5, identity)  // result = 120
    \end{code}
    
        In this example, "factorialCPS" recursively computes the factorial of "n". The continuation "cont" accumulates the result.
    
        \begin{itemize}
            \item Illustrates recursion in CPS.
            \item The continuation accumulates the result of the factorial.
            \item Shows how to handle complex computations in CPS.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{List Processing in CPS}
    
    CPS can be used for processing lists. This example demonstrates summing the elements of a list using CPS.
    
    \begin{highlight}[List Processing in CPS]
    
        This example shows how to sum the elements of a list using CPS.
    
    \begin{code}[Scala]
    // Summing a list in CPS
    def sumListCPS(lst: List[Int], cont: Int => Int): Int =
        lst match {
            case Nil => cont(0)
            case head :: tail => sumListCPS(tail, result => cont(head + result))
        }
    
    val result = sumListCPS(List(1, 2, 3, 4), identity)  // result = 10
    \end{code}
    
        In this example, "sumListCPS" recursively sums the elements of a list "lst". The continuation "cont" accumulates the sum.
    
        \begin{itemize}
            \item Demonstrates list processing in CPS.
            \item The continuation accumulates the sum of the list elements.
            \item Shows how to handle recursive data structures in CPS.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Error Handling in CPS}
    
    CPS can also be used for error handling, allowing errors to be managed through continuations.
    
    \begin{highlight}[Error Handling in CPS]
    
        This example demonstrates error handling using CPS.
    
    \begin{code}[Scala]
    // Division with error handling in CPS
    def safeDivideCPS(x: Int, y: Int, cont: Int => Int, errCont: String => Int): Int =
        if (y == 0) errCont("Division by zero")
        else cont(x / y)
    
    val result = safeDivideCPS(10, 0, result => result * 2, error => { println(error); 0 })  // prints "Division by zero", result = 0
    \end{code}
    
        In this example, "safeDivideCPS" divides "x" by "y", using an error continuation "errCont" to handle division by zero.
    
        \begin{itemize}
            \item Illustrates error handling in CPS.
            \item Uses an error continuation to manage errors.
            \item Demonstrates how to separate normal and error processing paths.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Non-Blocking I/O in CPS}
    
    CPS can be used to implement non-blocking I/O operations, facilitating asynchronous programming.
    
    \begin{highlight}[Non-Blocking I/O in CPS]
    
        This example shows how to perform non-blocking I/O using CPS.
    
    \begin{code}[Scala]
    // Non-blocking I/O example in pseudo-code
    def readFileCPS(filename: String, cont: String => Unit, errCont: String => Unit): Unit = {
        // Asynchronous I/O operation
        asyncReadFile(filename, content => cont(content), error => errCont(error))
    }
    
    readFileCPS("file.txt", content => println(content), error => println(s"Error: $error"))
    \end{code}
    
        In this example, "readFileCPS" performs a non-blocking file read. The success continuation "cont" handles the file content, and the error continuation "errCont" handles errors.
    
        \begin{itemize}
            \item Demonstrates non-blocking I/O in CPS.
            \item Uses continuations to handle success and error cases.
            \item Facilitates asynchronous programming.
        \end{itemize}
    
    \end{highlight}
    
    \begin{highlight}[Summary of Key Concepts]
    
        Continuation Passing Style (CPS) provides a flexible way to manage control flow in various programming tasks. Here are the key concepts covered in this section:
    
        \begin{itemize}
            \item \textbf{Basic Arithmetic in CPS}: Demonstrates how to perform arithmetic operations using CPS.
            \item \textbf{Factorial in CPS}: Illustrates recursive computations using CPS.
            \item \textbf{List Processing in CPS}: Shows how to process lists using CPS.
            \item \textbf{Error Handling in CPS}: Demonstrates error handling through continuations.
            \item \textbf{Non-Blocking I/O in CPS}: Illustrates how to perform non-blocking I/O operations using CPS.
        \end{itemize}
    
        These examples highlight the versatility of CPS in managing control flow and enabling advanced programming techniques.
    
    \end{highlight}
\end{notes}

The next topic that is being covered this week is \textbf{Continuation Passing Style Limitations}.

\begin{notes}{Continuation Passing Style Limitations}
    \subsection*{Overview}

    While Continuation Passing Style (CPS) offers powerful control over program execution and facilitates advanced programming techniques, it also has several limitations. Understanding these 
    limitations is crucial for effectively using CPS in practice.
    
    \subsubsection*{Complexity and Readability}
    
    CPS can introduce significant complexity into code, making it harder to read and understand. The explicit passing of continuations can lead to code that is less intuitive, especially for 
    those unfamiliar with CPS.
    
    \begin{highlight}[Complexity and Readability]
    
        This example demonstrates how CPS can make simple code more complex.
    
    \begin{code}[Scala]
    // Direct style
    def add(x: Int, y: Int): Int = x + y
    
    // CPS style
    def addCPS(x: Int, y: Int, cont: Int => Int): Int = cont(x + y)
    \end{code}
    
        In this example, the direct style "add" function is straightforward, while the CPS version "addCPS" is more complex due to the continuation.
    
        \begin{itemize}
            \item CPS increases code complexity.
            \item Makes code less intuitive and harder to read.
            \item Requires understanding of continuations to follow the logic.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Performance Overhead}
    
    CPS can introduce performance overhead due to the creation and invocation of continuation functions. This overhead can impact the efficiency of the program, especially in performance-critical applications.
    
    \begin{highlight}[Performance Overhead]
    
        This example shows how CPS can impact performance.
    
    \begin{code}[Scala]
    // Direct style
    def factorial(n: Int): Int =
        if (n == 0) 1 else n * factorial(n - 1)
    
    // CPS style
    def factorialCPS(n: Int, cont: Int => Int): Int =
        if (n == 0) cont(1)
        else factorialCPS(n - 1, result => cont(n * result))
    \end{code}
    
        In this example, the CPS version "factorialCPS" involves additional function calls and continuations, which can introduce overhead compared to the direct style "factorial".
    
        \begin{itemize}
            \item CPS introduces additional function calls and continuations.
            \item Can impact performance, especially in recursive functions.
            \item Important to consider overhead in performance-critical applications.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Stack Usage and Tail Call Optimization}
    
    Without proper tail call optimization, CPS can lead to increased stack usage, causing stack overflow errors in deeply recursive functions. Not all languages or runtime environments support tail call optimization.
    
    \begin{highlight}[Stack Usage and Tail Call Optimization]
    
        This example demonstrates the potential for increased stack usage in CPS.
    
    \begin{code}[Scala]
    // CPS without tail call optimization
    def sumListCPS(lst: List[Int], cont: Int => Int): Int =
        lst match {
            case Nil => cont(0)
            case head :: tail => sumListCPS(tail, result => cont(head + result))
        }
    \end{code}
    
        In this example, "sumListCPS" can lead to increased stack usage without tail call optimization, risking stack overflow for large lists.
    
        \begin{itemize}
            \item CPS can increase stack usage in the absence of tail call optimization.
            \item Not all languages or runtime environments support tail call optimization.
            \item Deeply recursive functions are particularly at risk.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Debugging Challenges}
    
    Debugging CPS code can be more challenging due to the non-linear control flow and the use of continuations. Understanding the execution path requires careful tracking of continuations and their invocations.
    
    \begin{highlight}[Debugging Challenges]
    
        This example illustrates the debugging challenges in CPS.
    
    \begin{code}[Scala]
    // CPS with complex control flow
    def complexCPS(x: Int, cont: Int => Int): Int =
        if (x < 0) cont(-1)
        else if (x == 0) cont(0)
        else complexCPS(x - 1, result => cont(result + x))
    \end{code}
    
        In this example, the control flow of "complexCPS" is non-linear, making it harder to debug and trace the execution path.
    
        \begin{itemize}
            \item Non-linear control flow complicates debugging.
            \item Requires careful tracking of continuations and their invocations.
            \item Debugging tools may not be well-suited for CPS code.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Maintainability Issues}
    
    Maintaining CPS code can be difficult due to its complexity and the intricate interplay of continuations. Changes to one part of the code can have far-reaching effects, making maintenance and 
    refactoring challenging.
    
    \begin{highlight}[Maintainability Issues]
    
        This example highlights the maintainability challenges in CPS.
    
    \begin{code}[Scala]
    // Complex CPS example
    def processCPS(data: List[Int], cont: Int => Int): Int =
        data match {
            case Nil => cont(0)
            case head :: tail =>
                processCPS(tail, result => cont(result + head * 2))
        }
    \end{code}
    
        In this example, modifying "processCPS" requires careful consideration of how changes affect the continuation chain, complicating maintenance.
    
        \begin{itemize}
            \item Complexity of CPS code complicates maintenance.
            \item Changes to continuations can have wide-reaching effects.
            \item Refactoring CPS code is challenging and error-prone.
        \end{itemize}
    
    \end{highlight}
    
    \begin{highlight}[Summary of Key Concepts]
    
        Continuation Passing Style (CPS) has several limitations that need to be considered when using this programming style. Here are the key concepts covered in this section:
    
        \begin{itemize}
            \item \textbf{Complexity and Readability}: CPS increases code complexity, making it harder to read and understand.
            \item \textbf{Performance Overhead}: CPS introduces additional function calls and continuations, impacting performance.
            \item \textbf{Stack Usage and Tail Call Optimization}: CPS can lead to increased stack usage without tail call optimization, risking stack overflow.
            \item \textbf{Debugging Challenges}: Non-linear control flow and continuations make debugging more challenging.
            \item \textbf{Maintainability Issues}: Complexity and intricate interplay of continuations complicate maintenance and refactoring.
        \end{itemize}
    
        These limitations highlight the trade-offs involved in using CPS and emphasize the need for careful consideration when adopting this style.
    
    \end{highlight}
\end{notes}

The next topic that is being covered this week is \textbf{Continuation Passing Style In Scala}.

\begin{notes}{Continuation Passing Style In Scala}
    \subsection*{Overview}

    Continuation Passing Style (CPS) in Scala is a programming technique where functions take an additional argument, a continuation, which represents the next step of computation. This technique 
    provides explicit control over the flow of execution and is useful for implementing advanced control structures, non-blocking I/O, and more.
    
    \subsubsection*{Defining Functions in CPS}
    
    In Scala, defining a function in CPS involves adding an additional parameter, the continuation, and modifying the function to pass its result to this continuation instead of returning it.
    
    \begin{highlight}[Defining Functions in CPS]
    
        This example demonstrates defining a simple function in CPS.
    
    \begin{code}[Scala]
    // Direct style function
    def add(x: Int, y: Int): Int = x + y
    
    // CPS function
    def addCPS(x: Int, y: Int, cont: Int => Int): Int = cont(x + y)
    
    // Using the CPS function
    val result = addCPS(3, 4, sum => sum * 2)  // result = 14
    \end{code}
    
        In this example, the "addCPS" function takes an additional parameter, "cont", which is a continuation function. The result of "x + y" is passed to "cont" instead of being returned directly.
    
        \begin{itemize}
            \item Functions take an additional continuation parameter.
            \item The continuation represents the next step of computation.
            \item The result is passed to the continuation instead of being returned.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Recursive Functions in CPS}
    
    Recursive functions can be defined in CPS to manage control flow explicitly, making them suitable for advanced programming techniques such as non-blocking I/O and concurrency.
    
    \begin{highlight}[Recursive Functions in CPS]
    
        This example demonstrates a recursive function in CPS.
    
    \begin{code}[Scala]
    // Direct style factorial function
    def factorial(n: Int): Int =
        if (n == 0) 1 else n * factorial(n - 1)
    
    // CPS factorial function
    def factorialCPS(n: Int, cont: Int => Int): Int =
        if (n == 0) cont(1)
        else factorialCPS(n - 1, result => cont(n * result))
    
    // Using the CPS factorial function
    val result = factorialCPS(5, identity)  // result = 120
    \end{code}
    
        In this example, "factorialCPS" uses CPS to compute the factorial of "n". The continuation "cont" accumulates the result of the recursive computation.
    
        \begin{itemize}
            \item Recursive functions in CPS take an additional continuation parameter.
            \item The continuation accumulates the result of the computation.
            \item Suitable for advanced programming techniques.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Error Handling in CPS}
    
    CPS can be used to implement error handling by passing error continuations alongside success continuations, enabling the separation of normal and error processing paths.
    
    \begin{highlight}[Error Handling in CPS]
    
        This example demonstrates error handling in CPS.
    
    \begin{code}[Scala]
    // CPS function with error handling
    def safeDivideCPS(x: Int, y: Int, cont: Int => Int, errCont: String => Int): Int =
        if (y == 0) errCont("Division by zero")
        else cont(x / y)
    
    // Using the CPS function with error handling
    val result = safeDivideCPS(10, 0, result => result * 2, error => { println(error); 0 })  // prints "Division by zero", result = 0
    \end{code}
    
        In this example, "safeDivideCPS" handles division by zero errors using an error continuation "errCont". The success continuation "cont" processes the result of the division.
    
        \begin{itemize}
            \item Error handling in CPS uses separate continuations for success and error paths.
            \item Enables the separation of normal and error processing.
            \item Facilitates robust error handling mechanisms.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Non-Blocking I/O in CPS}
    
    CPS is particularly useful for implementing non-blocking I/O operations, allowing asynchronous programming by passing continuations to handle the result of I/O operations.
    
    \begin{highlight}[Non-Blocking I/O in CPS]
    
        This example shows non-blocking I/O using CPS.
    
    \begin{code}[Scala]
    // Non-blocking I/O example in pseudo-code
    def readFileCPS(filename: String, cont: String => Unit, errCont: String => Unit): Unit = {
        // Asynchronous I/O operation
        asyncReadFile(filename, content => cont(content), error => errCont(error))
    }
    
    // Using the CPS function for non-blocking I/O
    readFileCPS("file.txt", content => println(content), error => println(s"Error: $error"))
    \end{code}
    
        In this example, "readFileCPS" performs a non-blocking file read. The success continuation "cont" handles the file content, while the error continuation "errCont" handles errors.
    
        \begin{itemize}
            \item CPS enables non-blocking I/O by using continuations to handle results.
            \item Facilitates asynchronous programming.
            \item Separates success and error handling paths.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Combining CPS with Scala's Future}
    
    Scala's "Future" can be used in conjunction with CPS to manage asynchronous computations, providing a higher-level abstraction for handling results and errors.
    
    \begin{highlight}[Combining CPS with Scala's Future]
    
        This example demonstrates combining CPS with Scala's "Future".
    
    \begin{code}[Scala]
    import scala.concurrent.{Future, ExecutionContext}
    import scala.util.{Success, Failure}
    import ExecutionContext.Implicits.global
    
    // CPS function with Future
    def futureCPS[A, B](future: Future[A], cont: A => B, errCont: Throwable => B): Future[B] = {
        future.map(cont).recover { case ex => errCont(ex) }
    }
    
    // Using the CPS function with Future
    val futureResult = futureCPS(Future { 10 / 2 }, result => result * 2, error => { println(error); 0 })
    futureResult.onComplete {
        case Success(value) => println(value)
        case Failure(exception) => println(s"Failed with: $exception")
    }
    \end{code}
    
        In this example, "futureCPS" combines CPS with "Future" to manage asynchronous computations. The success continuation "cont" processes the result, while the error continuation "errCont" handles errors.
    
        \begin{itemize}
            \item Combines CPS with "Future" for asynchronous computations.
            \item Uses continuations to handle results and errors.
            \item Provides a higher-level abstraction for managing asynchronous tasks.
        \end{itemize}
    
    \end{highlight}
    
    \begin{highlight}[Summary of Key Concepts]
    
        Continuation Passing Style (CPS) in Scala provides explicit control over the flow of execution and enables advanced programming techniques. Here are the key concepts covered in this section:
    
        \begin{itemize}
            \item \textbf{Defining Functions in CPS}: Functions take an additional continuation parameter, and the result is passed to the continuation.
            \item \textbf{Recursive Functions in CPS}: Recursive functions use continuations to manage control flow and accumulate results.
            \item \textbf{Error Handling in CPS}: Separate continuations for success and error handling facilitate robust error management.
            \item \textbf{Non-Blocking I/O in CPS}: Continuations handle results of non-blocking I/O operations, enabling asynchronous programming.
            \item \textbf{Combining CPS with Scala's Future}: CPS can be used with "Future" to manage asynchronous computations, providing a higher-level abstraction.
        \end{itemize}
    
        These concepts illustrate the power and flexibility of CPS in Scala, enabling advanced control structures and efficient asynchronous programming.
    
    \end{highlight}
\end{notes}

The next topic that is being covered this week is \textbf{Trampolines And Thunks}.

\begin{notes}{Trampolines And Thunks}
    \subsection*{Overview}

    Trampolines and thunks are techniques used to manage and optimize recursion in functional programming. They help avoid stack overflow by transforming recursive calls into iterative processes and 
    delaying computations.
    
    \subsubsection*{Trampolines}
    
    A trampoline is a loop that iteratively executes functions instead of making recursive calls directly. This allows deeply recursive functions to be executed without growing the call stack, thus 
    preventing stack overflow.
    
    \begin{highlight}[Trampolines]
    
        This example demonstrates using a trampoline to manage recursion.
    
    \begin{code}[Scala]
    sealed trait Trampoline[+A]
    case class Done[A](result: A) extends Trampoline[A]
    case class More[A](next: () => Trampoline[A]) extends Trampoline[A]
    
    def trampoline[A](t: Trampoline[A]): A = t match {
        case Done(result) => result
        case More(next) => trampoline(next())
    }
    
    // Recursive function using trampoline
    def factorial(n: Int, acc: Int = 1): Trampoline[Int] =
        if (n == 0) Done(acc)
        else More(() => factorial(n - 1, n * acc))
    
    val result = trampoline(factorial(5))  // result = 120
    \end{code}
    
        In this example, "factorial" uses a trampoline to manage recursion. The "trampoline" function iteratively executes "More" instances, preventing stack overflow.
    
        \begin{itemize}
            \item Trampolines convert recursive calls into iterative processes.
            \item Helps avoid stack overflow in deeply recursive functions.
            \item Executes functions iteratively using a loop.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Thunks}
    
    A thunk is a delayed computation represented as a parameterless function. Thunks are used to defer execution, enabling lazy evaluation and efficient handling of recursive calls.
    
    \begin{highlight}[Thunks]
    
        This example demonstrates using thunks to delay computation.
    
    \begin{code}[Scala]
    // Thunk as a delayed computation
    type Thunk[A] = () => A
    
    // Recursive function using thunks
    def factorialThunk(n: Int, acc: Int = 1): Thunk[Int] =
        if (n == 0) () => acc
        else () => factorialThunk(n - 1, n * acc)()
    
    val result = factorialThunk(5)()  // result = 120
    \end{code}
    
        In this example, "factorialThunk" uses thunks to delay the computation of the factorial. The recursive call is deferred, and the computation is executed when the thunk is invoked.
    
        \begin{itemize}
            \item Thunks represent delayed computations as parameterless functions.
            \item Enable lazy evaluation by deferring execution.
            \item Useful for managing recursive calls efficiently.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Combining Trampolines and Thunks}
    
    Combining trampolines and thunks can optimize recursive functions further by delaying computation and converting recursion to iteration, enhancing performance and preventing stack overflow.
    
    \begin{highlight}[Combining Trampolines and Thunks]
    
        This example demonstrates combining trampolines and thunks.
    
    \begin{code}[Scala]
    // Trampoline using thunks
    sealed trait Trampoline[+A]
    case class Done[A](result: A) extends Trampoline[A]
    case class More[A](next: Thunk[Trampoline[A]]) extends Trampoline[A]
    
    def trampoline[A](t: Trampoline[A]): A = t match {
        case Done(result) => result
        case More(next) => trampoline(next())
    }
    
    // Recursive function using trampoline and thunks
    def factorial(n: Int, acc: Int = 1): Trampoline[Int] =
        if (n == 0) Done(acc)
        else More(() => factorial(n - 1, n * acc))
    
    val result = trampoline(factorial(5))  // result = 120
    \end{code}
    
        In this example, "factorial" uses both trampolines and thunks to manage recursion. The "trampoline" function iteratively executes "More" instances, while thunks defer the computation.
    
        \begin{itemize}
            \item Combines trampolines and thunks for optimized recursion.
            \item Delays computation and converts recursion to iteration.
            \item Enhances performance and prevents stack overflow.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Advantages of Trampolines and Thunks}
    
    Using trampolines and thunks provides several benefits, including preventing stack overflow, enabling lazy evaluation, and improving performance in recursive functions.
    
    \begin{highlight}[Advantages of Trampolines and Thunks]
    
        The advantages of using trampolines and thunks include:
    
        \begin{itemize}
            \item \textbf{Prevents Stack Overflow}: Converts recursion to iteration, avoiding deep call stacks.
            \item \textbf{Enables Lazy Evaluation}: Thunks defer computation, allowing for more efficient execution.
            \item \textbf{Improves Performance}: Optimizes recursive functions by managing control flow and computation more effectively.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Applications of Trampolines and Thunks}
    
    Trampolines and thunks are useful in various applications, such as implementing interpreters, managing asynchronous computations, and optimizing recursive algorithms.
    
    \begin{highlight}[Applications of Trampolines and Thunks]
    
        Example applications include:
    
        \begin{itemize}
            \item \textbf{Interpreters}: Efficiently handle recursive evaluations and control flow in interpreters.
            \item \textbf{Asynchronous Computations}: Manage and optimize asynchronous tasks by deferring computations.
            \item \textbf{Optimizing Algorithms}: Improve performance of recursive algorithms by preventing stack overflow and optimizing control flow.
        \end{itemize}
    
    \end{highlight}
    
    \begin{highlight}[Summary of Key Concepts]
    
        Trampolines and thunks are powerful techniques for managing and optimizing recursion in functional programming. Here are the key concepts covered in this section:
    
        \begin{itemize}
            \item \textbf{Trampolines}: Convert recursive calls into iterative processes to avoid stack overflow.
            \item \textbf{Thunks}: Represent delayed computations as parameterless functions, enabling lazy evaluation.
            \item \textbf{Combining Trampolines and Thunks}: Optimize recursive functions by delaying computation and converting recursion to iteration.
            \item \textbf{Advantages of Trampolines and Thunks}: Prevent stack overflow, enable lazy evaluation, and improve performance.
            \item \textbf{Applications of Trampolines and Thunks}: Useful in interpreters, asynchronous computations, and optimizing recursive algorithms.
        \end{itemize}
    
        These techniques provide robust solutions for managing recursion and enhancing the efficiency of functional programs.
    
    \end{highlight}
\end{notes}

The next topic that is being covered this week is \textbf{Trampolines In Scala}.

\begin{notes}{Trampolines In Scala}
    \subsection*{Overview}

    Trampolines in Scala provide a way to manage and optimize recursive functions by converting them into iterative processes. This technique helps prevent stack overflow by executing functions 
    iteratively rather than through deep recursive calls.
    
    \subsubsection*{Defining Trampolines}
    
    In Scala, trampolines are implemented using a sealed trait and case classes that represent the different stages of computation. The "Done" case class represents a completed computation, while the 
    "More" case class represents a deferred computation.
    
    \begin{highlight}[Defining Trampolines]
    
        This example demonstrates how to define trampolines in Scala.
    
    \begin{code}[Scala]
    // Trampoline trait and case classes
    sealed trait Trampoline[+A]
    case class Done[A](result: A) extends Trampoline[A]
    case class More[A](next: () => Trampoline[A]) extends Trampoline[A]
    
    // Trampoline runner function
    def trampoline[A](t: Trampoline[A]): A = t match {
        case Done(result) => result
        case More(next) => trampoline(next())
    }
    \end{code}
    
        In this example, the "Trampoline" trait is defined with two case classes: "Done" for completed computations and "More" for deferred computations. The "trampoline" function iteratively executes 
        "More" instances until a "Done" instance is reached.
    
        \begin{itemize}
            \item Trampolines are defined using a sealed trait and case classes.
            \item "Done" represents a completed computation.
            \item "More" represents a deferred computation.
            \item The "trampoline" function iteratively executes deferred computations.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Using Trampolines for Recursion}
    
    Trampolines are particularly useful for managing recursive functions, transforming them into iterative processes to avoid stack overflow.
    
    \begin{highlight}[Using Trampolines for Recursion]
    
        This example demonstrates using trampolines for a recursive function.
    
    \begin{code}[Scala]
    // Recursive factorial function using trampolines
    def factorial(n: Int, acc: Int = 1): Trampoline[Int] =
        if (n == 0) Done(acc)
        else More(() => factorial(n - 1, n * acc))
    
    // Running the trampoline
    val result = trampoline(factorial(5))  // result = 120
    \end{code}
    
        In this example, the "factorial" function uses trampolines to compute the factorial of "n". The computation is deferred using "More", and the "trampoline" function executes the deferred 
        computations iteratively.
    
        \begin{itemize}
            \item Trampolines convert recursive functions into iterative processes.
            \item Avoid stack overflow by deferring computations.
            \item The "trampoline" function manages the execution of deferred computations.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Complex Recursive Functions with Trampolines}
    
    Trampolines can handle more complex recursive functions, such as those involving multiple recursive calls or more intricate logic.
    
    \begin{highlight}[Complex Recursive Functions with Trampolines]
    
        This example demonstrates a more complex recursive function using trampolines.
    
    \begin{code}[Scala]
    // Fibonacci function using trampolines
    def fibonacci(n: Int): Trampoline[Int] =
        if (n <= 1) Done(n)
        else for {
            a <- More(() => fibonacci(n - 1))
            b <- More(() => fibonacci(n - 2))
        } yield a + b
    
    // Running the trampoline
    val result = trampoline(fibonacci(5))  // result = 5
    \end{code}
    
        In this example, the "fibonacci" function computes the Fibonacci number of "n" using trampolines. The computation involves multiple recursive calls, which are deferred using "More" and 
        combined using "for"-comprehension.
    
        \begin{itemize}
            \item Trampolines can manage complex recursive functions with multiple calls.
            \item Deferred computations are combined using "for"-comprehension.
            \item Prevents stack overflow in complex recursive scenarios.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Integrating Trampolines with Existing Code}
    
    Integrating trampolines into existing Scala code involves modifying recursive functions to use "Done" and "More" cases and ensuring the "trampoline" function is used to execute them.
    
    \begin{highlight}[Integrating Trampolines with Existing Code]
    
        This example shows how to integrate trampolines into existing code.
    
    \begin{code}[Scala]
    // Existing recursive function
    def sumList(lst: List[Int]): Int =
        lst match {
            case Nil => 0
            case head :: tail => head + sumList(tail)
        }
    
    // Modified function using trampolines
    def sumListTrampoline(lst: List[Int]): Trampoline[Int] =
        lst match {
            case Nil => Done(0)
            case head :: tail => More(() => sumListTrampoline(tail)).flatMap(tailSum => Done(head + tailSum))
        }
    
    // Running the trampoline
    val result = trampoline(sumListTrampoline(List(1, 2, 3, 4)))  // result = 10
    \end{code}
    
        In this example, the existing "sumList" function is modified to use trampolines. The recursive calls are deferred using "More", and the "trampoline" function executes the deferred computations.
    
        \begin{itemize}
            \item Modify recursive functions to use "Done" and "More" cases.
            \item Use the "trampoline" function to execute deferred computations.
            \item Integrates trampolines seamlessly with existing code.
        \end{itemize}
    
    \end{highlight}
    
    \begin{highlight}[Summary of Key Concepts]
    
        Trampolines in Scala provide a robust technique for managing and optimizing recursive functions. Here are the key concepts covered in this section:
    
        \begin{itemize}
            \item \textbf{Defining Trampolines}: Use a sealed trait and case classes ("Done" and "More") to represent stages of computation.
            \item \textbf{Using Trampolines for Recursion}: Convert recursive functions into iterative processes to avoid stack overflow.
            \item \textbf{Complex Recursive Functions with Trampolines}: Handle more complex recursion involving multiple calls using trampolines.
            \item \textbf{Integrating Trampolines with Existing Code}: Modify existing recursive functions to use trampolines and execute them with the "trampoline" function.
        \end{itemize}
    
        These techniques ensure efficient and safe execution of recursive functions in Scala, preventing stack overflow and optimizing performance.
    
    \end{highlight}
\end{notes}

The next topic that is being covered this week is \textbf{Continuations In Scala}.

\begin{notes}{Continuations In Scala}
    \subsection*{Overview}

    Continuations in Scala are a powerful feature that allows for advanced control flow mechanisms. They enable functions to save their state and resume execution at a later point, facilitating 
    complex programming techniques such as coroutines, backtracking, and asynchronous computations.
    
    \subsubsection*{What are Continuations?}
    
    Continuations represent the future steps of a computation. In Scala, continuations can be captured and manipulated to control the flow of execution explicitly.
    
    \begin{highlight}[What are Continuations?]
    
        This example provides a basic understanding of continuations.
    
    \begin{code}[Scala]
    // Direct style function
    def add(x: Int, y: Int): Int = x + y
    
    // Continuation-passing style function
    def addCPS(x: Int, y: Int, cont: Int => Int): Int = cont(x + y)
    
    // Using the CPS function
    val result = addCPS(3, 4, sum => sum * 2)  // result = 14
    \end{code}
    
        In this example, "addCPS" takes an additional parameter, "cont", which is a continuation function. Instead of returning the result directly, it passes the result to "cont".
    
        \begin{itemize}
            \item Continuations represent the future steps of a computation.
            \item Functions can save their state and resume execution later.
            \item Facilitates complex control flow mechanisms.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Using Continuations in Scala}
    
    Scala provides a way to work with continuations through the "scala.util.continuations" package, which includes the "shift" and "reset" constructs for manipulating continuations.
    
    \begin{highlight}[Using Continuations in Scala]
    
        This example demonstrates using "shift" and "reset" in Scala.
    
    \begin{code}[Scala]
    import scala.util.continuations._
    
    def example(): Int @cps[Int] = reset {
        val x = shift { k: (Int => Int) => k(k(k(7))) }
        x + 1
    }
    
    val result = example()  // result = 10
    \end{code}
    
        In this example, "reset" delimits the continuation, and "shift" captures the continuation, allowing it to be invoked multiple times.
    
        \begin{itemize}
            \item "reset" delimits the continuation.
            \item "shift" captures the continuation and allows manipulation.
            \item Enables advanced control flow by explicitly managing continuations.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Implementing Coroutines with Continuations}
    
    Coroutines can be implemented using continuations, allowing functions to yield control back and forth, facilitating cooperative multitasking.
    
    \begin{highlight}[Implementing Coroutines with Continuations]
    
        This example shows how to implement coroutines using continuations in Scala.
    
    \begin{code}[Scala]
    import scala.util.continuations._
    
    def coroutineExample(): Unit = {
        var state = 0
        reset {
            while (true) {
                println(s"Coroutine state: $state")
                state += 1
                shift { k: (Unit => Unit) => k(()) }
            }
        }
    }
    
    coroutineExample()  // prints "Coroutine state: 0", "Coroutine state: 1", etc.
    \end{code}
    
        In this example, "coroutineExample" uses "reset" and "shift" to implement a coroutine that yields control after each iteration of the loop.
    
        \begin{itemize}
            \item Coroutines allow functions to yield control back and forth.
            \item "shift" captures the continuation, enabling the coroutine to resume execution.
            \item Facilitates cooperative multitasking.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Backtracking with Continuations}
    
    Continuations can also be used for backtracking algorithms, allowing functions to explore different execution paths and revert to previous states when necessary.
    
    \begin{highlight}[Backtracking with Continuations]
    
        This example demonstrates backtracking using continuations in Scala.
    
    \begin{code}[Scala]
    import scala.util.continuations._
    
    def backtrackExample(): Boolean @cps[Boolean] = reset {
        def tryOption(opt: Boolean): Boolean @cps[Boolean] = shift { k: (Boolean => Boolean) =>
            if (opt) k(true) else k(false)
        }
        val result1 = tryOption(false)
        val result2 = tryOption(true)
        result1 && result2
    }
    
    val result = backtrackExample()  // result = false
    \end{code}
    
        In this example, "backtrackExample" uses "shift" and "reset" to implement backtracking, exploring different execution paths and reverting to previous states as needed.
    
        \begin{itemize}
            \item Continuations enable backtracking by capturing and manipulating execution paths.
            \item "shift" and "reset" facilitate exploring different options.
            \item Useful for implementing algorithms that require exploring multiple solutions.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Asynchronous Computations with Continuations}
    
    Continuations can be used to manage asynchronous computations, enabling non-blocking I/O operations and concurrent programming.
    
    \begin{highlight}[Asynchronous Computations with Continuations]
    
        This example demonstrates using continuations for asynchronous computations in Scala.
    
    \begin{code}[Scala]
    import scala.concurrent._
    import scala.concurrent.ExecutionContext.Implicits.global
    import scala.util.continuations._
    
    def asyncExample(): Future[Int] = Future {
        reset {
            val x = shift { k: (Int => Int) =>
                Future {
                    k(7)
                }
                0
            }
            x + 1
        }
    }
    
    val result = asyncExample()
    result.onComplete(println)  // prints Success(8)
    \end{code}
    
        In this example, "asyncExample" uses "shift" and "reset" to handle an asynchronous computation, with "shift" capturing the continuation and managing it within a "Future".
    
        \begin{itemize}
            \item Continuations manage asynchronous computations.
            \item "shift" captures the continuation for non-blocking execution.
            \item Facilitates concurrent programming by integrating with Scala's "Future".
        \end{itemize}
    
    \end{highlight}
    
    \begin{highlight}[Summary of Key Concepts]
    
        Continuations in Scala provide a powerful tool for managing control flow and enabling advanced programming techniques. Here are the key concepts covered in this section:
    
        \begin{itemize}
            \item \textbf{What are Continuations?}: Represent the future steps of a computation, allowing functions to save and resume their state.
            \item \textbf{Using Continuations in Scala}: Utilize the "shift" and "reset" constructs from "scala.util.continuations" to manipulate continuations.
            \item \textbf{Implementing Coroutines with Continuations}: Enable cooperative multitasking by yielding control back and forth.
            \item \textbf{Backtracking with Continuations}: Explore different execution paths and revert to previous states using continuations.
            \item \textbf{Asynchronous Computations with Continuations}: Manage non-blocking I/O and concurrent programming by capturing continuations within asynchronous tasks.
        \end{itemize}
    
        These concepts demonstrate the versatility and power of continuations in Scala, enabling complex control flow mechanisms and efficient asynchronous programming.
    
    \end{highlight}
\end{notes}

The last topic that is being covered this week is \textbf{Generics In Scala}.

\begin{notes}{Generics In Scala}
    \subsection*{Overview}

    Generics in Scala allow for the definition of classes, traits, and methods that operate on types specified as parameters. This provides a way to create flexible and reusable components that can 
    work with any data type, enhancing type safety and reducing code duplication.
    
    \subsubsection*{Defining Generic Classes}
    
    Generic classes in Scala are defined using type parameters. This enables the class to operate on different types while maintaining type safety.
    
    \begin{highlight}[Defining Generic Classes]
    
        This example demonstrates defining a generic class in Scala.
    
    \begin{code}[Scala]
    // Generic class definition
    class Box[T](val value: T)
    
    // Creating instances of the generic class
    val intBox = new Box 
    val stringBox = new Box[String]("Hello")
    \end{code}
    
        In this example, "Box" is a generic class that takes a type parameter "T". Instances of "Box" can be created with different types, such as "Int" and "String".
    
        \begin{itemize}
            \item Generic classes are defined using type parameters.
            \item Enables the class to operate on different types while maintaining type safety.
            \item Reduces code duplication by creating reusable components.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Defining Generic Methods}
    
    Generic methods allow methods to operate on types specified as parameters, providing flexibility in method operations.
    
    \begin{highlight}[Defining Generic Methods]
    
        This example demonstrates defining a generic method in Scala.
    
    \begin{code}[Scala]
    // Generic method definition
    def identity[T](value: T): T = value
    
    // Using the generic method
    val intIdentity = identity(42)
    val stringIdentity = identity("Hello")
    \end{code}
    
        In this example, "identity" is a generic method that takes a type parameter "T" and returns a value of the same type. The method can be used with different types, such as "Int" and "String".
    
        \begin{itemize}
            \item Generic methods are defined using type parameters.
            \item Provides flexibility in method operations.
            \item Enables the method to operate on different types while maintaining type safety.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Generic Traits}
    
    Traits in Scala can also be generic, allowing them to be mixed into classes with different types.
    
    \begin{highlight}[Generic Traits]
    
        This example demonstrates defining a generic trait in Scala.
    
    \begin{code}[Scala]
    // Generic trait definition
    trait Container[T] {
        def value: T
    }
    
    // Class mixing in the generic trait
    class Box[T](val value: T) extends Container[T]
    
    // Using the generic trait
    val intBox: Container 
    val stringBox: Container[String] = new Box[String]("Hello")
    \end{code}
    
        In this example, "Container" is a generic trait with a type parameter "T". The "Box" class mixes in this trait, and instances of "Box" can be created with different types.
    
        \begin{itemize}
            \item Generic traits are defined using type parameters.
            \item Can be mixed into classes with different types.
            \item Provides flexibility and reusability in trait definitions.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Variance in Generics}
    
    Variance annotations in Scala (covariant, contravariant, and invariant) specify how subtyping between more complex types relates to subtyping between their components.
    
    \begin{highlight}[Variance in Generics]
    
        This example demonstrates variance annotations in Scala.
    
    \begin{code}[Scala]
    // Covariant definition
    class Covariant[+A]
    
    // Contravariant definition
    class Contravariant[-A]
    
    // Invariant definition
    class Invariant[A]
    
    // Covariance example
    val covariantList: Covariant[Any] = new Covariant[String]
    
    // Contravariance example
    val contravariantFunction: Contravariant[String] = new Contravariant[Any]
    \end{code}
    
        In this example, "Covariant" is a covariant class, "Contravariant" is a contravariant class, and "Invariant" is an invariant class. Variance annotations control how types relate to subtyping.
    
        \begin{itemize}
            \item \textbf{Covariance (+A)}: Allows a generic class to accept subtypes (e.g., "List[+A]").
            \item \textbf{Contravariance (-A)}: Allows a generic class to accept supertypes (e.g., "Function1[-A, +B]").
            \item \textbf{Invariant (A)}: No variance, exact type matching.
        \end{itemize}
    
    \end{highlight}
    
    \subsubsection*{Bounds in Generics}
    
    Type bounds in Scala restrict the types that can be used as type parameters. Upper and lower bounds are used to enforce these restrictions.
    
    \begin{highlight}[Bounds in Generics]
    
        This example demonstrates type bounds in Scala.
    
    \begin{code}[Scala]
    // Upper bound example
    def upperBoundExample[A <: Number](value: A): A = value
    
    // Lower bound example
    def lowerBoundExample[A >: String](value: A): A = value
    
    // Using the methods with bounds
    val numberResult = upperBoundExample(42)  // Valid: Int is a subtype of Number
    val stringResult = lowerBoundExample("Hello")  // Valid: String is a supertype of String
    \end{code}
    
        In this example, "upperBoundExample" uses an upper bound "<: Number", restricting the type parameter to "Number" or its subtypes. "lowerBoundExample" uses a lower bound ">: String", restricting 
        the type parameter to "String" or its supertypes.
    
        \begin{itemize}
            \item Upper bounds restrict type parameters to a specific type or its subtypes.
            \item Lower bounds restrict type parameters to a specific type or its supertypes.
            \item Provides control over the types that can be used with generic methods and classes.
        \end{itemize}
    
    \end{highlight}
    
    \begin{highlight}[Summary of Key Concepts]
    
        Generics in Scala provide a powerful mechanism for creating flexible and reusable components. Here are the key concepts covered in this section:
    
        \begin{itemize}
            \item \textbf{Defining Generic Classes}: Use type parameters to create classes that operate on different types.
            \item \textbf{Defining Generic Methods}: Use type parameters to create methods that operate on different types.
            \item \textbf{Generic Traits}: Define traits with type parameters that can be mixed into classes with different types.
            \item \textbf{Variance in Generics}: Use variance annotations (covariant, contravariant, invariant) to control type relationships.
            \item \textbf{Bounds in Generics}: Use upper and lower bounds to restrict the types that can be used as type parameters.
        \end{itemize}
    
        These concepts illustrate the versatility and power of generics in Scala, enabling the creation of type-safe and reusable code components.
    
    \end{highlight}
\end{notes}